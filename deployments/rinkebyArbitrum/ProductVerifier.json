{
  "address": "0x6968Cd4B86732089A8943A82F48E9220B4Fe7FD8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IPredyV3Pool",
          "name": "_pool",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "zeroToOne",
          "type": "bool"
        }
      ],
      "name": "PositionUpdated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "collateral0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collateral1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt1",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "isCollateral",
                  "type": "bool"
                },
                {
                  "internalType": "uint128",
                  "name": "liquidity",
                  "type": "uint128"
                },
                {
                  "internalType": "int24",
                  "name": "lowerTick",
                  "type": "int24"
                },
                {
                  "internalType": "int24",
                  "name": "upperTick",
                  "type": "int24"
                }
              ],
              "internalType": "struct PositionVerifier.LPT[]",
              "name": "lpts",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct PositionVerifier.Position",
          "name": "position",
          "type": "tuple"
        },
        {
          "internalType": "bool",
          "name": "isMarginZero",
          "type": "bool"
        }
      ],
      "name": "generateProof",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isDebt",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isMin",
              "type": "bool"
            },
            {
              "internalType": "int24",
              "name": "tick",
              "type": "int24"
            }
          ],
          "internalType": "struct PositionVerifier.Proof[]",
          "name": "proofs",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestedAmount",
          "type": "uint256"
        },
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "lower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upper",
          "type": "int24"
        }
      ],
      "name": "getLiquidityAndAmount",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        },
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "collateral0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "collateral1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt1",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "isCollateral",
                  "type": "bool"
                },
                {
                  "internalType": "uint128",
                  "name": "liquidity",
                  "type": "uint128"
                },
                {
                  "internalType": "int24",
                  "name": "lowerTick",
                  "type": "int24"
                },
                {
                  "internalType": "int24",
                  "name": "upperTick",
                  "type": "int24"
                }
              ],
              "internalType": "struct PositionVerifier.LPT[]",
              "name": "lpts",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct PositionVerifier.Position",
          "name": "position",
          "type": "tuple"
        },
        {
          "internalType": "uint160",
          "name": "sqrtPrice",
          "type": "uint160"
        }
      ],
      "name": "getRequiredTokenAmounts",
      "outputs": [
        {
          "internalType": "int256",
          "name": "totalAmount0",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "totalAmount1",
          "type": "int256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_vaultId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "collateral0",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "collateral1",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debt0",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "debt1",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "bool",
                      "name": "isCollateral",
                      "type": "bool"
                    },
                    {
                      "internalType": "uint128",
                      "name": "liquidity",
                      "type": "uint128"
                    },
                    {
                      "internalType": "int24",
                      "name": "lowerTick",
                      "type": "int24"
                    },
                    {
                      "internalType": "int24",
                      "name": "upperTick",
                      "type": "int24"
                    }
                  ],
                  "internalType": "struct PositionVerifier.LPT[]",
                  "name": "lpts",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct PositionVerifier.Position",
              "name": "position",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "isDebt",
                  "type": "bool"
                },
                {
                  "internalType": "bool",
                  "name": "isMin",
                  "type": "bool"
                },
                {
                  "internalType": "int24",
                  "name": "tick",
                  "type": "int24"
                }
              ],
              "internalType": "struct PositionVerifier.Proof[]",
              "name": "proofs",
              "type": "tuple[]"
            },
            {
              "internalType": "uint256",
              "name": "amountInMaximum",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isLiquidationRequired",
              "type": "bool"
            }
          ],
          "internalType": "struct IProductVerifier.OpenPositionParams",
          "name": "_params",
          "type": "tuple"
        }
      ],
      "name": "openPosition",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pool",
      "outputs": [
        {
          "internalType": "contract IPredyV3Pool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "_threshold",
          "type": "int256"
        }
      ],
      "name": "setThreshold",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "threshold",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x40cb854f9f49f17baaff0a0763c4bc27d964b5ad6c6da4237b99e465b227f549",
  "receipt": {
    "to": null,
    "from": "0x1c745d31A084a14Ba30E7c9F4B14EA762d44f194",
    "contractAddress": "0x6968Cd4B86732089A8943A82F48E9220B4Fe7FD8",
    "transactionIndex": 1,
    "gasUsed": "2450592",
    "logsBloom": "0x00000000000000000000000000000000400000000000000000800000000000000000000000000000002000000000000000000000000000000000020000000000000000000000000000000000000000000001000200000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000000000000000000",
    "blockHash": "0xe33cccd3c7da0123657f996cc261fea12423146033ea3af3a4aa2756f6a48b95",
    "transactionHash": "0x40cb854f9f49f17baaff0a0763c4bc27d964b5ad6c6da4237b99e465b227f549",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 13985483,
        "transactionHash": "0x40cb854f9f49f17baaff0a0763c4bc27d964b5ad6c6da4237b99e465b227f549",
        "address": "0x6968Cd4B86732089A8943A82F48E9220B4Fe7FD8",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000001c745d31a084a14ba30e7c9f4b14ea762d44f194"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xe33cccd3c7da0123657f996cc261fea12423146033ea3af3a4aa2756f6a48b95"
      }
    ],
    "blockNumber": 13985483,
    "cumulativeGasUsed": "2450592",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xdA882DB5f056B09CE88748aA9D8d7279F599a678"
  ],
  "solcInputHash": "41a72310410cb1f4618c1c11f5cf05d3",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IPredyV3Pool\",\"name\":\"_pool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"zeroToOne\",\"type\":\"bool\"}],\"name\":\"PositionUpdated\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collateral0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt1\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollateral\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"}],\"internalType\":\"struct PositionVerifier.LPT[]\",\"name\":\"lpts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PositionVerifier.Position\",\"name\":\"position\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isMarginZero\",\"type\":\"bool\"}],\"name\":\"generateProof\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isDebt\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMin\",\"type\":\"bool\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"internalType\":\"struct PositionVerifier.Proof[]\",\"name\":\"proofs\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"lower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upper\",\"type\":\"int24\"}],\"name\":\"getLiquidityAndAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collateral0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt1\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollateral\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"}],\"internalType\":\"struct PositionVerifier.LPT[]\",\"name\":\"lpts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PositionVerifier.Position\",\"name\":\"position\",\"type\":\"tuple\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPrice\",\"type\":\"uint160\"}],\"name\":\"getRequiredTokenAmounts\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"totalAmount0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"totalAmount1\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collateral0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt1\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollateral\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"}],\"internalType\":\"struct PositionVerifier.LPT[]\",\"name\":\"lpts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PositionVerifier.Position\",\"name\":\"position\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isDebt\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMin\",\"type\":\"bool\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"internalType\":\"struct PositionVerifier.Proof[]\",\"name\":\"proofs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLiquidationRequired\",\"type\":\"bool\"}],\"internalType\":\"struct IProductVerifier.OpenPositionParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"openPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract IPredyV3Pool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_threshold\",\"type\":\"int256\"}],\"name\":\"setThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/ProductVerifier.sol\":\"ProductVerifier\"},\"evmVersion\":\"istanbul\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363539363337353433393936\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0 <0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = -denominator & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x50e87f7a3197525d1c6f7e04290060e848677c8a4e86c554bc6ace4a4d0d476d\",\"license\":\"MIT\"},\"lib/forge-std/lib/ds-test/src/test.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.5.0;\\n\\ncontract DSTest {\\n    event log                    (string);\\n    event logs                   (bytes);\\n\\n    event log_address            (address);\\n    event log_bytes32            (bytes32);\\n    event log_int                (int);\\n    event log_uint               (uint);\\n    event log_bytes              (bytes);\\n    event log_string             (string);\\n\\n    event log_named_address      (string key, address val);\\n    event log_named_bytes32      (string key, bytes32 val);\\n    event log_named_decimal_int  (string key, int val, uint decimals);\\n    event log_named_decimal_uint (string key, uint val, uint decimals);\\n    event log_named_int          (string key, int val);\\n    event log_named_uint         (string key, uint val);\\n    event log_named_bytes        (string key, bytes val);\\n    event log_named_string       (string key, string val);\\n\\n    bool public IS_TEST = true;\\n    bool private _failed;\\n\\n    address constant HEVM_ADDRESS =\\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\\n\\n    modifier mayRevert() { _; }\\n    modifier testopts(string memory) { _; }\\n\\n    function failed() public returns (bool) {\\n        if (_failed) {\\n            return _failed;\\n        } else {\\n            bool globalFailed = false;\\n            if (hasHEVMContext()) {\\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\\n                    abi.encodePacked(\\n                        bytes4(keccak256(\\\"load(address,bytes32)\\\")),\\n                        abi.encode(HEVM_ADDRESS, bytes32(\\\"failed\\\"))\\n                    )\\n                );\\n                globalFailed = abi.decode(retdata, (bool));\\n            }\\n            return globalFailed;\\n        }\\n    } \\n\\n    function fail() internal {\\n        if (hasHEVMContext()) {\\n            (bool status, ) = HEVM_ADDRESS.call(\\n                abi.encodePacked(\\n                    bytes4(keccak256(\\\"store(address,bytes32,bytes32)\\\")),\\n                    abi.encode(HEVM_ADDRESS, bytes32(\\\"failed\\\"), bytes32(uint256(0x01)))\\n                )\\n            );\\n            status; // Silence compiler warnings\\n        }\\n        _failed = true;\\n    }\\n\\n    function hasHEVMContext() internal view returns (bool) {\\n        uint256 hevmCodeSize = 0;\\n        assembly {\\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\\n        }\\n        return hevmCodeSize > 0;\\n    }\\n\\n    modifier logs_gas() {\\n        uint startGas = gasleft();\\n        _;\\n        uint endGas = gasleft();\\n        emit log_named_uint(\\\"gas\\\", startGas - endGas);\\n    }\\n\\n    function assertTrue(bool condition) internal {\\n        if (!condition) {\\n            emit log(\\\"Error: Assertion Failed\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertTrue(bool condition, string memory err) internal {\\n        if (!condition) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertTrue(condition);\\n        }\\n    }\\n\\n    function assertEq(address a, address b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [address]\\\");\\n            emit log_named_address(\\\"  Expected\\\", b);\\n            emit log_named_address(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n    function assertEq(address a, address b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(bytes32 a, bytes32 b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [bytes32]\\\");\\n            emit log_named_bytes32(\\\"  Expected\\\", b);\\n            emit log_named_bytes32(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEq32(bytes32 a, bytes32 b) internal {\\n        assertEq(a, b);\\n    }\\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\\n        assertEq(a, b, err);\\n    }\\n\\n    function assertEq(int a, int b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Expected\\\", b);\\n            emit log_named_int(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n    function assertEq(int a, int b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEq(uint a, uint b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Expected\\\", b);\\n            emit log_named_uint(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n    function assertEq(uint a, uint b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEqDecimal(int a, int b, uint decimals) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Expected\\\", b, decimals);\\n            emit log_named_decimal_int(\\\"    Actual\\\", a, decimals);\\n            fail();\\n        }\\n    }\\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEqDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Expected\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\"    Actual\\\", a, decimals);\\n            fail();\\n        }\\n    }\\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEqDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertGt(uint a, uint b) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGt(uint a, uint b, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGt(a, b);\\n        }\\n    }\\n    function assertGt(int a, int b) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGt(int a, int b, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGt(a, b);\\n        }\\n    }\\n    function assertGtDecimal(int a, int b, uint decimals) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGtDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGtDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertGe(uint a, uint b) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGe(uint a, uint b, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGe(a, b);\\n        }\\n    }\\n    function assertGe(int a, int b) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGe(int a, int b, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGe(a, b);\\n        }\\n    }\\n    function assertGeDecimal(int a, int b, uint decimals) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertLt(uint a, uint b) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLt(uint a, uint b, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLt(a, b);\\n        }\\n    }\\n    function assertLt(int a, int b) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLt(int a, int b, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLt(a, b);\\n        }\\n    }\\n    function assertLtDecimal(int a, int b, uint decimals) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLtDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLtDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertLe(uint a, uint b) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLe(uint a, uint b, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLe(a, b);\\n        }\\n    }\\n    function assertLe(int a, int b) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLe(int a, int b, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLe(a, b);\\n        }\\n    }\\n    function assertLeDecimal(int a, int b, uint decimals) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLeDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertEq(string memory a, string memory b) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log(\\\"Error: a == b not satisfied [string]\\\");\\n            emit log_named_string(\\\"  Expected\\\", b);\\n            emit log_named_string(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n    function assertEq(string memory a, string memory b, string memory err) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\\n        ok = true;\\n        if (a.length == b.length) {\\n            for (uint i = 0; i < a.length; i++) {\\n                if (a[i] != b[i]) {\\n                    ok = false;\\n                }\\n            }\\n        } else {\\n            ok = false;\\n        }\\n    }\\n    function assertEq0(bytes memory a, bytes memory b) internal {\\n        if (!checkEq0(a, b)) {\\n            emit log(\\\"Error: a == b not satisfied [bytes]\\\");\\n            emit log_named_bytes(\\\"  Expected\\\", b);\\n            emit log_named_bytes(\\\"    Actual\\\", a);\\n            fail();\\n        }\\n    }\\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\\n        if (!checkEq0(a, b)) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq0(a, b);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb39cd1d5220cb474947b131e15a4538334b7e886af244b440ae5c9c6bba96a54\",\"license\":\"GPL-3.0-or-later\"},\"lib/forge-std/src/Script.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.6.0 <0.9.0;\\n\\nimport \\\"./Vm.sol\\\";\\nimport \\\"./console.sol\\\";\\nimport \\\"./console2.sol\\\";\\n\\nabstract contract Script {\\n    address constant private VM_ADDRESS =\\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\\n\\n    Vm public constant vm = Vm(VM_ADDRESS);\\n}\\n\",\"keccak256\":\"0x24ed91a7f3ba4ee9c82940f0d2d9d71fc4adfb98b3874715cb565e92574f7f11\",\"license\":\"Unlicense\"},\"lib/forge-std/src/Test.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.6.0 <0.9.0;\\n\\nimport \\\"./Script.sol\\\";\\nimport \\\"lib/forge-std/lib/ds-test/src/test.sol\\\";\\n\\n// Wrappers around Cheatcodes to avoid footguns\\nabstract contract Test is DSTest, Script {\\n    using stdStorage for StdStorage;\\n\\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    event WARNING_Deprecated(string msg);\\n\\n    StdStorage internal stdstore;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    STD-CHEATS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    // Skip forward or rewind time by the specified number of seconds\\n    function skip(uint256 time) public {\\n        vm.warp(block.timestamp + time);\\n    }\\n\\n    function rewind(uint256 time) public {\\n        vm.warp(block.timestamp - time);\\n    }\\n\\n    // Setup a prank from an address that has some ether\\n    function hoax(address who) public {\\n        vm.deal(who, 1 << 128);\\n        vm.prank(who);\\n    }\\n\\n    function hoax(address who, uint256 give) public {\\n        vm.deal(who, give);\\n        vm.prank(who);\\n    }\\n\\n    function hoax(address who, address origin) public {\\n        vm.deal(who, 1 << 128);\\n        vm.prank(who, origin);\\n    }\\n\\n    function hoax(address who, address origin, uint256 give) public {\\n        vm.deal(who, give);\\n        vm.prank(who, origin);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    function startHoax(address who) public {\\n        vm.deal(who, 1 << 128);\\n        vm.startPrank(who);\\n    }\\n\\n    function startHoax(address who, uint256 give) public {\\n        vm.deal(who, give);\\n        vm.startPrank(who);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    // tx.origin is set to the origin parameter\\n    function startHoax(address who, address origin) public {\\n        vm.deal(who, 1 << 128);\\n        vm.startPrank(who, origin);\\n    }\\n\\n    function startHoax(address who, address origin, uint256 give) public {\\n        vm.deal(who, give);\\n        vm.startPrank(who, origin);\\n    }\\n\\n    function changePrank(address who) internal {\\n        vm.stopPrank();\\n        vm.startPrank(who);\\n    }\\n\\n    // DEPRECATED: Use `deal` instead\\n    function tip(address token, address to, uint256 give) public {\\n        emit WARNING_Deprecated(\\\"The `tip` stdcheat has been deprecated. Use `deal` instead.\\\");\\n        stdstore\\n            .target(token)\\n            .sig(0x70a08231)\\n            .with_key(to)\\n            .checked_write(give);\\n    }\\n\\n    // The same as Hevm's `deal`\\n    // Use the alternative signature for ERC20 tokens\\n    function deal(address to, uint256 give) public {\\n        vm.deal(to, give);\\n    }\\n\\n    // Set the balance of an account for any ERC20 token\\n    // Use the alternative signature to update `totalSupply`\\n    function deal(address token, address to, uint256 give) public {\\n        deal(token, to, give, false);\\n    }\\n\\n    function deal(address token, address to, uint256 give, bool adjust) public {\\n        // get current balance\\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore\\n            .target(token)\\n            .sig(0x70a08231)\\n            .with_key(to)\\n            .checked_write(give);\\n\\n        // update total supply\\n        if(adjust){\\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if(give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore\\n                .target(token)\\n                .sig(0x18160ddd)\\n                .checked_write(totSup);\\n        }\\n    }\\n\\n    function bound(uint256 x, uint256 min, uint256 max) public returns (uint256 result) {\\n        require(min <= max, \\\"Test bound(uint256,uint256,uint256): Max is less than min.\\\");\\n\\n        uint256 size = max - min;\\n\\n        if (size == 0)\\n        {\\n            result = min;\\n        }\\n        else if (size == UINT256_MAX)\\n        {\\n            result = x;\\n        }\\n        else\\n        {\\n            ++size; // make `max` inclusive\\n            uint256 mod = x % size;\\n            result = min + mod;\\n        }\\n\\n        emit log_named_uint(\\\"Bound Result\\\", result);\\n    }\\n\\n    // Deploy a contract by fetching the contract bytecode from\\n    // the artifacts directory\\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\\n    function deployCode(string memory what, bytes memory args)\\n        public\\n        returns (address addr)\\n    {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(\\n            addr != address(0),\\n            \\\"Test deployCode(string,bytes): Deployment failed.\\\"\\n        );\\n    }\\n\\n    function deployCode(string memory what)\\n        public\\n        returns (address addr)\\n    {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(\\n            addr != address(0),\\n            \\\"Test deployCode(string): Deployment failed.\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    STD-ASSERTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function fail(string memory err) internal virtual {\\n        emit log_named_string(\\\"Error\\\", err);\\n        fail();\\n    }\\n\\n    function assertFalse(bool data) internal virtual {\\n        assertTrue(!data);\\n    }\\n\\n    function assertFalse(bool data, string memory err) internal virtual {\\n        assertTrue(!data, err);\\n    }\\n\\n    function assertEq(bool a, bool b) internal {\\n        if (a != b) {\\n            emit log                (\\\"Error: a == b not satisfied [bool]\\\");\\n            emit log_named_string   (\\\"  Expected\\\", b ? \\\"true\\\" : \\\"false\\\");\\n            emit log_named_string   (\\\"    Actual\\\", a ? \\\"true\\\" : \\\"false\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(bool a, bool b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(bytes memory a, bytes memory b) internal {\\n        assertEq0(a, b);\\n    }\\n\\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\\n        assertEq0(a, b, err);\\n    }\\n\\n    function assertApproxEqAbs(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxDelta\\n    ) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log            (\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_uint (\\\"  Expected\\\", b);\\n            emit log_named_uint (\\\"    Actual\\\", a);\\n            emit log_named_uint (\\\" Max Delta\\\", maxDelta);\\n            emit log_named_uint (\\\"     Delta\\\", delta);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbs(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxDelta,\\n        string memory err\\n    ) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string   (\\\"Error\\\", err);\\n            assertApproxEqAbs(a, b, maxDelta);\\n        }\\n    }\\n\\n    function assertApproxEqAbs(\\n        int256 a,\\n        int256 b,\\n        uint256 maxDelta\\n    ) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log            (\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_int  (\\\"  Expected\\\", b);\\n            emit log_named_int  (\\\"    Actual\\\", a);\\n            emit log_named_uint (\\\" Max Delta\\\", maxDelta);\\n            emit log_named_uint (\\\"     Delta\\\", delta);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbs(\\n        int256 a,\\n        int256 b,\\n        uint256 maxDelta,\\n        string memory err\\n    ) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string   (\\\"Error\\\", err);\\n            assertApproxEqAbs(a, b, maxDelta);\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log                    (\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_uint         (\\\"    Expected\\\", b);\\n            emit log_named_uint         (\\\"      Actual\\\", a);\\n            emit log_named_decimal_uint (\\\" Max % Delta\\\", maxPercentDelta, 18);\\n            emit log_named_decimal_uint (\\\"     % Delta\\\", percentDelta, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        string memory err\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string       (\\\"Error\\\", err);\\n            assertApproxEqRel(a, b, maxPercentDelta);\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        int256 a,\\n        int256 b,\\n        uint256 maxPercentDelta\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log                   (\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_int         (\\\"    Expected\\\", b);\\n            emit log_named_int         (\\\"      Actual\\\", a);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        int256 a,\\n        int256 b,\\n        uint256 maxPercentDelta,\\n        string memory err\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string      (\\\"Error\\\", err);\\n            assertApproxEqRel(a, b, maxPercentDelta);\\n        }\\n    }\\n}\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                STD-ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nlibrary stdError {\\n    bytes public constant assertionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x01);\\n    bytes public constant arithmeticError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x11);\\n    bytes public constant divisionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x12);\\n    bytes public constant enumConversionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x21);\\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x22);\\n    bytes public constant popError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x31);\\n    bytes public constant indexOOBError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x32);\\n    bytes public constant memOverflowError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x41);\\n    bytes public constant zeroVarError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x51);\\n    // DEPRECATED: Use Hevm's `expectRevert` without any arguments instead\\n    bytes public constant lowLevelError = bytes(\\\"\\\"); // `0x`\\n}\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                STD-STORAGE\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nstruct StdStorage {\\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\\n\\n    bytes32[] _keys;\\n    bytes4 _sig;\\n    uint256 _depth;\\n    address _target;\\n    bytes32 _set;\\n}\\n\\nlibrary stdStorage {\\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\\n    event WARNING_UninitedSlot(address who, uint slot);\\n\\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\\n\\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\\n\\n    function sigs(\\n        string memory sigStr\\n    )\\n        internal\\n        pure\\n        returns (bytes4)\\n    {\\n        return bytes4(keccak256(bytes(sigStr)));\\n    }\\n\\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\\n    // slot complexity:\\n    //  if flat, will be bytes32(uint256(uint));\\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\\n    function find(\\n        StdStorage storage self\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        // calldata to test against\\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n        }\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        vm_std_store.record();\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32*field_depth);\\n        }\\n\\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\\n        if (reads.length == 1) {\\n            bytes32 curr = vm_std_store.load(who, reads[0]);\\n            if (curr == bytes32(0)) {\\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\\n            }\\n            if (fdat != curr) {\\n                require(false, \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isnt supported\\\");\\n            }\\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n        } else if (reads.length > 1) {\\n            for (uint256 i = 0; i < reads.length; i++) {\\n                bytes32 prev = vm_std_store.load(who, reads[i]);\\n                if (prev == bytes32(0)) {\\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\\n                }\\n                // store\\n                vm_std_store.store(who, reads[i], bytes32(hex\\\"1337\\\"));\\n                bool success;\\n                bytes memory rdat;\\n                {\\n                    (success, rdat) = who.staticcall(cald);\\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\\n                }\\n\\n                if (success && fdat == bytes32(hex\\\"1337\\\")) {\\n                    // we found which of the slots is the actual one\\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n                    vm_std_store.store(who, reads[i], prev);\\n                    break;\\n                }\\n                vm_std_store.store(who, reads[i], prev);\\n            }\\n        } else {\\n            require(false, \\\"stdStorage find(StdStorage): No storage use detected for target.\\\");\\n        }\\n\\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \\\"stdStorage find(StdStorage): Slot(s) not found.\\\");\\n\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n\\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        self._target = _target;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        self._sig = _sig;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        self._sig = sigs(_sig);\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(uint256(uint160(who))));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(amt));\\n        return self;\\n    }\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        self._keys.push(key);\\n        return self;\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        self._depth = _depth;\\n        return self;\\n    }\\n\\n    function checked_write(StdStorage storage self, address who) internal {\\n        checked_write(self, bytes32(uint256(uint160(who))));\\n    }\\n\\n    function checked_write(StdStorage storage self, uint256 amt) internal {\\n        checked_write(self, bytes32(amt));\\n    }\\n\\n    function checked_write(StdStorage storage self, bool write) internal {\\n        bytes32 t;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            t := write\\n        }\\n        checked_write(self, t);\\n    }\\n\\n    function checked_write(\\n        StdStorage storage self,\\n        bytes32 set\\n    ) internal {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            find(self);\\n        }\\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\\n\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32*field_depth);\\n        }\\n        bytes32 curr = vm_std_store.load(who, slot);\\n\\n        if (fdat != curr) {\\n            require(false, \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isnt supported.\\\");\\n        }\\n        vm_std_store.store(who, slot, set);\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n    }\\n\\n    function read(StdStorage storage self) private returns (bytes memory) {\\n        address t = self._target;\\n        uint256 s = find(self);\\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return abi.decode(read(self), (bytes32));\\n    }\\n\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        return abi.decode(read(self), (bool));\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return abi.decode(read(self), (address));\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return abi.decode(read(self), (uint256));\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return abi.decode(read(self), (int256));\\n    }\\n\\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\\n    {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                STD-MATH\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nlibrary stdMath {\\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n\\n    function abs(int256 a) internal pure returns (uint256) {\\n        // Required or it will fail when `a = type(int256).min`\\n        if (a == INT256_MIN)\\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n\\n        return uint256(a >= 0 ? a : -a);\\n    }\\n\\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b\\n            ? a - b\\n            : b - a;\\n    }\\n\\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\\n        // a and b are of the same sign\\n        if (a >= 0 && b >= 0 || a < 0 && b < 0) {\\n            return delta(abs(a), abs(b));\\n        }\\n\\n        // a and b are of opposite signs\\n        return abs(a) + abs(b);\\n    }\\n\\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n\\n        return absDelta * 1e18 / b;\\n    }\\n\\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n        uint256 absB = abs(b);\\n\\n        return absDelta * 1e18 / absB;\\n    }\\n}\\n\",\"keccak256\":\"0x48fee1b3217adfb6c6ebf7b7a626f46130921e9fd82a44474a243e55ff3a77ca\",\"license\":\"Unlicense\"},\"lib/forge-std/src/Vm.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.6.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface Vm {\\n    // Set block.timestamp (newTimestamp)\\n    function warp(uint256) external;\\n    // Set block.height (newHeight)\\n    function roll(uint256) external;\\n    // Set block.basefee (newBasefee)\\n    function fee(uint256) external;\\n    // Set block.chainid\\n    function chainId(uint256) external;\\n    // Loads a storage slot from an address (who, slot)\\n    function load(address,bytes32) external returns (bytes32);\\n    // Stores a value to an address' storage slot, (who, slot, value)\\n    function store(address,bytes32,bytes32) external;\\n    // Signs data, (privateKey, digest) => (v, r, s)\\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\\n    // Gets address for a given private key, (privateKey) => (address)\\n    function addr(uint256) external returns (address);\\n    // Gets the nonce of an account\\n    function getNonce(address) external returns (uint64);\\n    // Sets the nonce of an account; must be higher than the current nonce of the account\\n    function setNonce(address, uint64) external;\\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\\n    function ffi(string[] calldata) external returns (bytes memory);\\n    // Set environment variables, (name, value)\\n    function setEnv(string calldata, string calldata) external;\\n    // Read environment variables, (name) => (value)\\n    function envBool(string calldata) external returns (bool);\\n    function envUint(string calldata) external returns (uint256);\\n    function envInt(string calldata) external returns (int256);\\n    function envAddress(string calldata) external returns (address);\\n    function envBytes32(string calldata) external returns (bytes32);\\n    function envString(string calldata) external returns (string memory);\\n    function envBytes(string calldata) external returns (bytes memory);\\n    // Read environment variables as arrays, (name, delim) => (value[])\\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\\n    function envString(string calldata, string calldata) external returns (string[] memory);\\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\\n    // Sets the *next* call's msg.sender to be the input address\\n    function prank(address) external;\\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\\n    function startPrank(address) external;\\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\\n    function prank(address,address) external;\\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\\n    function startPrank(address,address) external;\\n    // Resets subsequent calls' msg.sender to be `address(this)`\\n    function stopPrank() external;\\n    // Sets an address' balance, (who, newBalance)\\n    function deal(address, uint256) external;\\n    // Sets an address' code, (who, newCode)\\n    function etch(address, bytes calldata) external;\\n    // Expects an error on next call\\n    function expectRevert(bytes calldata) external;\\n    function expectRevert(bytes4) external;\\n    function expectRevert() external;\\n    // Record all storage reads and writes\\n    function record() external;\\n    // Gets all accessed reads and write slot from a recording session, for a given address\\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\\n    function expectEmit(bool,bool,bool,bool) external;\\n    function expectEmit(bool,bool,bool,bool,address) external;\\n    // Mocks a call to an address, returning specified data.\\n    // Calldata can either be strict or a partial match, e.g. if you only\\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\\n    // function will be mocked.\\n    function mockCall(address,bytes calldata,bytes calldata) external;\\n    // Mocks a call to an address with a specific msg.value, returning specified data.\\n    // Calldata match takes precedence over msg.value in case of ambiguity.\\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\\n    // Clears all mocked calls\\n    function clearMockedCalls() external;\\n    // Expect a call to an address with the specified calldata.\\n    // Calldata can either be strict or a partial match\\n    function expectCall(address,bytes calldata) external;\\n    // Expect a call to an address with the specified msg.value and calldata\\n    function expectCall(address,uint256,bytes calldata) external;\\n    // Gets the code from an artifact file. Takes in the relative path to the json file\\n    function getCode(string calldata) external returns (bytes memory);\\n    // Labels an address in call traces\\n    function label(address, string calldata) external;\\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\\n    function assume(bool) external;\\n    // Set block.coinbase (who)\\n    function coinbase(address) external;\\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\\n    function broadcast() external;\\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\\n    function broadcast(address) external;\\n    // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\\n    function startBroadcast() external;\\n    // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\\n    function startBroadcast(address) external;\\n    // Stops collecting onchain transactions\\n    function stopBroadcast() external;\\n}\\n\",\"keccak256\":\"0xf8da64f97f592b18a64c889b1b249f973424c8dddf288f7e90e881160ce103f2\",\"license\":\"Unlicense\"},\"lib/forge-std/src/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba\",\"license\":\"MIT\"},\"lib/forge-std/src/console2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\\n\\nlibrary console2 {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0xbeb823fcdb356244a83aaccdf828ad019ecc1ffaa3dff18e624fc6d5714ea671\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x549c5343ad9f7e3f38aa4c4761854403502574bbc15b822db2ce892ff9b79da7\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xe22a1fc7400ae196eba2ad1562d0386462b00a6363b742d55a2fd2021a58586f\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xba085261d44cf28d2583f7c8cdb2f0a6a495ff1a640f86d995ea9d36b42b0046\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3cb350f04ff49cfb10aef08d87f19dcbaecc8027b0bed12f3275cd12f38cf0\",\"license\":\"MIT\"},\"lib/v3-core/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(MAX_TICK), 'T');\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    }\\n}\\n\",\"keccak256\":\"0x1f864a2bf61ba05f3173eaf2e3f94c5e1da4bec0554757527b6d1ef1fe439e4e\",\"license\":\"GPL-2.0-or-later\"},\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\\n\\n/// @title Liquidity amount functions\\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\\nlibrary LiquidityAmounts {\\n    /// @notice Downcasts uint256 to uint128\\n    /// @param x The uint258 to be downcasted\\n    /// @return y The passed value, downcasted to uint128\\n    function toUint128(uint256 x) private pure returns (uint128 y) {\\n        require((y = uint128(x)) == x);\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount0 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount0(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount1 The amount1 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount1(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\\n    }\\n\\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount of token0 being sent in\\n    /// @param amount1 The amount of token1 being sent in\\n    /// @return liquidity The maximum amount of liquidity received\\n    function getLiquidityForAmounts(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\n\\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\n        } else {\\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\n        }\\n    }\\n\\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    function getAmount0ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return\\n            FullMath.mulDiv(\\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\\n                sqrtRatioBX96 - sqrtRatioAX96,\\n                sqrtRatioBX96\\n            ) / sqrtRatioAX96;\\n    }\\n\\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount1 The amount of token1\\n    function getAmount1ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n    }\\n\\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    /// @return amount1 The amount of token1\\n    function getAmountsForLiquidity(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\n        } else {\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf149581d28e1c81736dfe72be73ee1301d4945340cc6282fcdd63fe3c85abf24\",\"license\":\"GPL-2.0-or-later\"},\"src/ProductVerifier.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"./interfaces/IPredyV3Pool.sol\\\";\\nimport \\\"./interfaces/IProductVerifier.sol\\\";\\nimport \\\"./libraries/PositionVerifier.sol\\\";\\nimport \\\"./libraries/LPTMath.sol\\\";\\n\\ncontract ProductVerifier is IProductVerifier, Ownable {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    IPredyV3Pool public pool;\\n    int256 public threshold;\\n\\n    event PositionUpdated(uint256 vaultId, uint256 amount0, uint256 amount1, bool zeroToOne);\\n\\n    constructor(\\n        IPredyV3Pool _pool\\n    ) {\\n        pool = _pool;\\n        threshold = 200;\\n    }\\n\\n    function setThreshold(int256 _threshold)\\n        external\\n    {\\n        threshold = _threshold;\\n    }\\n\\n    function getRequiredTokenAmounts(PositionVerifier.Position memory position, uint160 sqrtPrice)\\n        external\\n        pure\\n        returns (int256 totalAmount0, int256 totalAmount1)\\n    {\\n        return PositionVerifier.getAmounts(position, sqrtPrice);\\n    }\\n\\n    function openPosition(\\n        uint256 _vaultId,\\n        OpenPositionParams memory _params\\n    ) external override returns (uint256, uint256) {\\n        PositionVerifier.Position memory position = _params.position;\\n\\n        int256 requiredAmount0 = int256(position.collateral0) - int256(position.debt0);\\n        int256 requiredAmount1 = int256(position.collateral1) - int256(position.debt1);\\n\\n        // TODO: enter market\\n        pool.depositTokens(_vaultId, position.collateral0, position.collateral1, _params.isLiquidationRequired);\\n        pool.borrowTokens(_vaultId, position.debt0, position.debt1);\\n\\n        for (uint256 i = 0; i < position.lpts.length; i++) {\\n            if (position.lpts[i].isCollateral) {\\n                (uint256 amount0InLPT, uint256 amount1InLPT) = pool.depositLPT(\\n                    _vaultId,\\n                    position.lpts[i].lowerTick,\\n                    position.lpts[i].upperTick,\\n                    position.lpts[i].liquidity\\n                );\\n                requiredAmount0 = requiredAmount0.add(int256(amount0InLPT));\\n                requiredAmount1 = requiredAmount1.add(int256(amount1InLPT));\\n            } else {\\n                (uint256 amount0InLPT, uint256 amount1InLPT) = pool.borrowLPT(\\n                    _vaultId,\\n                    position.lpts[i].lowerTick,\\n                    position.lpts[i].upperTick,\\n                    position.lpts[i].liquidity\\n                );\\n                requiredAmount0 = requiredAmount0.sub(int256(amount0InLPT));\\n                requiredAmount1 = requiredAmount1.sub(int256(amount1InLPT));\\n            }\\n        }\\n\\n        if (!_params.isLiquidationRequired) {\\n            PositionVerifier.verifyPosition(pool.getPosition(_vaultId), _params.proofs, pool.isMarginZero(), threshold);\\n        }\\n\\n        if (requiredAmount0 > 0 && requiredAmount1 < 0) {\\n            uint256 requiredA1 = pool.swapExactOutput(false, uint256(requiredAmount0), _params.amountInMaximum);\\n\\n            emit PositionUpdated(_vaultId, uint256(requiredAmount0), requiredA1, false);\\n\\n            return (0, requiredA1.sub(uint256(-requiredAmount1)));\\n        }\\n\\n        if (requiredAmount1 > 0 && requiredAmount0 < 0) {\\n            uint256 requiredA0 = pool.swapExactOutput(true, uint256(requiredAmount1), _params.amountInMaximum);\\n\\n            emit PositionUpdated(_vaultId, requiredA0, uint256(requiredAmount1), true);\\n\\n            return (requiredA0.sub(uint256(-requiredAmount0)), 0);\\n        }\\n\\n        if (requiredAmount1 >= 0 && requiredAmount0 >= 0) {\\n            return (uint256(requiredAmount0), uint256(requiredAmount1));\\n        }\\n\\n        // out of the money\\n        return (0, 0);\\n    }\\n\\n    function getLiquidityAndAmount(\\n        uint256 requestedAmount,\\n        int24 tick,\\n        int24 lower,\\n        int24 upper\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        return LPTMath.getLiquidityAndAmountToBorrow(pool.isMarginZero(), requestedAmount, tick, lower, upper);\\n    }\\n\\n    function generateProof(PositionVerifier.Position memory position, bool isMarginZero) external pure returns (PositionVerifier.Proof[] memory proofs) {\\n        return PositionVerifier.generateProof(position, isMarginZero);\\n    }\\n}\\n\",\"keccak256\":\"0xf92b4dac0a890c5de008543c0cbcf13000c74748826bcad8d2e7aca82ba83b62\",\"license\":\"agpl-3.0\"},\"src/interfaces/IPredyV3Pool.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./IProductVerifier.sol\\\";\\nimport \\\"../libraries/PositionVerifier.sol\\\";\\n\\ninterface IPredyV3Pool {\\n    enum InstantDebtType {\\n        NONE,\\n        LONG,\\n        SHORT\\n    }\\n\\n    function isMarginZero() external view returns (bool);\\n\\n    function openPosition(\\n        uint256 _vaultId,\\n        uint256 _margin,\\n        IProductVerifier.OpenPositionParams memory _params,\\n         uint256 _buffer0,\\n        uint256 _buffer1\\n    ) external returns (uint256 vaultId);\\n\\n    function closePositionsInVault(\\n        uint256 _vaultId,\\n        bool _zeroOrOne,\\n        uint256 _amount,\\n        uint256 _amountOutMinimum\\n    ) external;\\n\\n    function swapExactOutput(\\n        bool _zeroForOne,\\n        uint256 _amountOut,\\n        uint256 _amountInMaximum\\n    ) external returns (uint256);\\n\\n    function getTokenAmountsToBorrowLPT(\\n        bytes32 _rangeId,\\n        uint128 _liquidity,\\n        uint160 _sqrtPrice\\n    ) external view returns (uint256, uint256);\\n\\n    function getPosition(uint256 _vaultId) external view returns (PositionVerifier.Position memory position);\\n\\n    function depositTokens(\\n        uint256 _vaultId,\\n        uint256 _amount0,\\n        uint256 _amount1,\\n        bool _withEnteringMarket\\n    ) external;\\n\\n    function depositLPT(\\n        uint256 _vaultId,\\n        int24 _lower,\\n        int24 _upper,\\n        uint128 _liquidity\\n    ) external returns (uint256, uint256);\\n\\n    function borrowTokens(\\n        uint256 _vaultId,\\n        uint256 _amount0,\\n        uint256 _amount1\\n    ) external;\\n\\n    function borrowLPT(\\n        uint256 _vaultId,\\n        int24 _lower,\\n        int24 _upper,\\n        uint128 _liquidity\\n    ) external returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0x39574e9cc7d124ef715c6db47aa4f9b15e098abb1809ce555f63b0d08f976d74\",\"license\":\"agpl-3.0\"},\"src/interfaces/IProductVerifier.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../libraries/PositionVerifier.sol\\\";\\n\\ninterface IProductVerifier {\\n    struct OpenPositionParams {\\n        PositionVerifier.Position position;\\n        PositionVerifier.Proof[] proofs;\\n        uint256 amountInMaximum;\\n        bool isLiquidationRequired;\\n    }\\n\\n    function openPosition(\\n        uint256 _vaultId,\\n        OpenPositionParams memory _params\\n    ) external returns (uint256, uint256);\\n\\n    function getLiquidityAndAmount(\\n        uint256 requestedAmount,\\n        int24 tick,\\n        int24 lower,\\n        int24 upper\\n    )\\n        external\\n        view\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        );\\n}\\n\",\"keccak256\":\"0x8c6a83395471c057101f5e3bc30fa216520edcdb62e9cbf7885b7ad37e1bbe97\",\"license\":\"agpl-3.0\"},\"src/libraries/LPTMath.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\\\";\\nimport \\\"lib/v3-core/contracts/libraries/TickMath.sol\\\";\\n\\nlibrary LPTMath {\\n\\n    // calculate liquidity for amount\\n    // amount -> liquidity, amount0, amount1\\n    //\\n    // borrow\\n    //  tick1 -> upper, tick2 -> option type\\n    //  enough amount to borrow\\n    //\\n    // deposit\\n    //  tick1 -> current, tick2 -> current\\n    //  \\n    //\\n\\n    function getLiquidityAndAmountToDeposit(\\n        bool isMarginZero,\\n        uint256 requestedAmount,\\n        uint160 currentSqrtPrice,\\n        int24 lower,\\n        int24 upper\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        if (isMarginZero) {\\n            return getLiquidityAndAmount(\\n                0,\\n                requestedAmount,\\n                TickMath.getSqrtRatioAtTick(upper),\\n                currentSqrtPrice,\\n                lower,\\n                upper\\n            );\\n        } else {\\n            return getLiquidityAndAmount(\\n                requestedAmount,\\n                0,\\n                TickMath.getSqrtRatioAtTick(lower),\\n                currentSqrtPrice,\\n                lower,\\n                upper\\n            );\\n        }\\n    }    \\n\\n    function getLiquidityAndAmountToBorrow(\\n        bool isMarginZero,\\n        uint256 requestedAmount,\\n        int24 tick,\\n        int24 lower,\\n        int24 upper\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        if (isMarginZero) {\\n            return getLiquidityAndAmount(\\n                0,\\n                requestedAmount,\\n                TickMath.getSqrtRatioAtTick(upper),\\n                TickMath.getSqrtRatioAtTick(tick),\\n                lower,\\n                upper\\n            );\\n        } else {\\n            return getLiquidityAndAmount(\\n                requestedAmount,\\n                0,\\n                TickMath.getSqrtRatioAtTick(lower),\\n                TickMath.getSqrtRatioAtTick(tick),\\n                lower,\\n                upper\\n            );\\n        }\\n    }\\n\\n    function getLiquidityAndAmount(\\n        uint256 requestedAmount0,\\n        uint256 requestedAmount1,\\n        uint160 sqrtPrice1,\\n        uint160 sqrtPrice2,\\n        int24 lower,\\n        int24 upper\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        (liquidity) = LiquidityAmounts.getLiquidityForAmounts(\\n            sqrtPrice1,\\n            TickMath.getSqrtRatioAtTick(lower),\\n            TickMath.getSqrtRatioAtTick(upper),\\n            requestedAmount0,\\n            requestedAmount1\\n        );\\n\\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\\n            sqrtPrice2,\\n            TickMath.getSqrtRatioAtTick(lower),\\n            TickMath.getSqrtRatioAtTick(upper),\\n            liquidity\\n        );\\n    }\\n\\n\\n    function getAmountsForLiquidity(uint160 currentSqrtPrice, int24 _lower, int24 _upper, uint128 _liquidity)\\n        internal\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        return LiquidityAmounts.getAmountsForLiquidity(\\n            currentSqrtPrice, \\n            TickMath.getSqrtRatioAtTick(_lower),\\n            TickMath.getSqrtRatioAtTick(_upper),\\n            _liquidity\\n        );\\n    }\\n\\n    function getSqrtRatioAtTick(int24 _tick) internal pure returns(uint160) {\\n        return TickMath.getSqrtRatioAtTick(_tick);\\n    }\\n\\n    function decodeSqrtPriceX96(bool isMarginZero, uint256 sqrtPriceX96) internal pure returns (uint256 price) {\\n        uint256 scaler = 1e18; //10**ERC20(token0).decimals();\\n\\n        if (isMarginZero) {\\n            price = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint256(2**(96 * 2)) / (scaler));\\n            if (price == 0) return 1e36;\\n            price = 1e36 / price;\\n        } else {\\n            price = (FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint256(2**96)) * scaler) / uint256(2**96);\\n        }\\n\\n        if (price > 1e36) price = 1e36;\\n        else if (price == 0) price = 1;\\n    }\\n\\n}\\n\",\"keccak256\":\"0x2d290a7db94a7f407be02d8f14cbd96bc1e8bc6834b0c5f59da31b37b5391e22\",\"license\":\"UNLICENSED\"},\"src/libraries/PositionVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\\\";\\nimport \\\"lib/v3-core/contracts/libraries/TickMath.sol\\\";\\nimport \\\"lib/forge-std/src/Test.sol\\\";\\nimport \\\"lib/forge-std/src/Vm.sol\\\";\\n\\nlibrary PositionVerifier {\\n    struct LPT {\\n        bool isCollateral;\\n        uint128 liquidity;\\n        int24 lowerTick;\\n        int24 upperTick;\\n    }\\n\\n    struct Position {\\n        uint256 collateral0;\\n        uint256 collateral1;\\n        uint256 debt0;\\n        uint256 debt1;\\n        LPT[] lpts;\\n    }\\n\\n    struct Proof {\\n        bool isDebt;\\n        bool isMin;\\n        int24 tick;\\n    }\\n\\n    function verifyPosition(\\n        Position memory position,\\n        Proof[] memory proofs,\\n        bool isMarginZero,\\n        int256 _threshold\\n    ) internal pure returns (bool) {\\n        if (position.lpts.length == 0) {\\n            return false;\\n        }\\n        require(position.lpts.length == proofs.length, \\\"0\\\");\\n\\n        checkOrder(position);\\n\\n        for (uint256 i = 0; i < proofs.length; i++) {\\n            if (proofs[i].isDebt) {\\n                require(!position.lpts[i].isCollateral, \\\"7\\\");\\n                if (proofs[i].isMin) {\\n                    require(\\n                        position.lpts[i].lowerTick <= proofs[i].tick && proofs[i].tick <= position.lpts[i].upperTick,\\n                        \\\"1\\\"\\n                    );\\n                    int256 delta = getDelta(position, proofs[i].tick, isMarginZero);\\n                    require(-_threshold <= delta && delta <= _threshold, \\\"2\\\");\\n                    require(getValue(position, TickMath.getSqrtRatioAtTick(proofs[i].tick), isMarginZero) >= 0, \\\"3\\\");\\n                } else {\\n                    require(\\n                        getDelta(position, position.lpts[i].lowerTick, isMarginZero) *\\n                            getDelta(position, position.lpts[i].upperTick, isMarginZero) >=\\n                            0,\\n                        \\\"4\\\"\\n                    );\\n                }\\n            } else {\\n                require(position.lpts[i].isCollateral);\\n            }\\n        }\\n\\n        if (isMarginZero) {\\n            require(getLeftSideDelta(position, isMarginZero) >= -_threshold, \\\"5\\\");\\n            require(getRightSideDelta(position, isMarginZero) <= _threshold, \\\"6\\\");\\n        } else {\\n            require(getLeftSideDelta(position, isMarginZero) <= _threshold, \\\"5\\\");\\n            require(getRightSideDelta(position, isMarginZero) >= -_threshold, \\\"6\\\");\\n        }\\n\\n        return true;\\n    }\\n\\n    function checkOrder(Position memory position) internal pure returns (int256) {\\n        int24 tick = -887220;\\n\\n        for (uint256 i = 0; i < position.lpts.length; i++) {\\n            require(position.lpts[i].lowerTick < position.lpts[i].upperTick);\\n            require(tick <= position.lpts[i].lowerTick);\\n            tick = position.lpts[i].upperTick;\\n        }\\n    }\\n\\n    function getAmounts(Position memory position, uint160 sqrtPrice)\\n        internal\\n        pure\\n        returns (int256 totalAmount0, int256 totalAmount1)\\n    {\\n        for (uint256 i = 0; i < position.lpts.length; i++) {\\n            (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\\n                sqrtPrice,\\n                TickMath.getSqrtRatioAtTick(position.lpts[i].lowerTick),\\n                TickMath.getSqrtRatioAtTick(position.lpts[i].upperTick),\\n                position.lpts[i].liquidity\\n            );\\n\\n            if (position.lpts[i].isCollateral) {\\n                totalAmount0 += int256(amount0);\\n                totalAmount1 += int256(amount1);\\n            } else {\\n                totalAmount0 -= int256(amount0);\\n                totalAmount1 -= int256(amount1);\\n            }\\n        }\\n\\n        totalAmount0 += int256(position.collateral0);\\n        totalAmount1 += int256(position.collateral1);\\n        totalAmount0 -= int256(position.debt0);\\n        totalAmount1 -= int256(position.debt1);\\n    }\\n\\n    function getValue(\\n        Position memory position,\\n        uint160 sqrtPrice,\\n        bool isMarginZero\\n    ) internal pure returns (int256) {\\n        uint256 price = decodeSqrtPriceX96(sqrtPrice);\\n\\n        (int256 amount0, int256 amount1) = getAmounts(position, sqrtPrice);\\n\\n        if (isMarginZero) {\\n            return amount0 + (amount1 * int256(price)) / 1e18;\\n        } else {\\n            return (amount0 * int256(price)) / 1e18 + amount1;\\n        }\\n    }\\n\\n    function getLeftSideDelta(Position memory position, bool isMarginZero) internal pure returns (int256) {\\n        if (position.lpts.length == 0) {\\n            return getDelta(position, 0, isMarginZero);\\n        }\\n\\n        return getDelta(position, position.lpts[0].lowerTick, isMarginZero);\\n    }\\n\\n    function getRightSideDelta(Position memory position, bool isMarginZero) internal pure returns (int256) {\\n        if (position.lpts.length == 0) {\\n            return getDelta(position, 0, isMarginZero);\\n        }\\n\\n        return getDelta(position, position.lpts[0].upperTick, isMarginZero);\\n    }\\n\\n    function getDelta(\\n        Position memory position,\\n        int24 tick,\\n        bool isMarginZero\\n    ) internal pure returns (int256) {\\n        (int256 amount0, int256 amount1) = getAmounts(position, TickMath.getSqrtRatioAtTick(tick));\\n\\n        if (isMarginZero) {\\n            return amount1;\\n        } else {\\n            return amount0;\\n        }\\n    }\\n\\n    function decodeSqrtPriceX96(uint256 sqrtPriceX96) private pure returns (uint256 price) {\\n        uint256 scaler = 1; //10**ERC20(token0).decimals();\\n\\n        price = (FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint256(2**96)) * scaler) / uint256(2**96);\\n\\n        if (price > 1e36) price = 1e36;\\n        else if (price == 0) price = 1;\\n    }\\n\\n    // generate proof\\n\\n    function generateProof(Position memory position, bool isMarginZero) internal pure returns (Proof[] memory proofs) {\\n        proofs = new Proof[](position.lpts.length);\\n\\n        for (uint256 i = 0; i < position.lpts.length; i++) {\\n            if (position.lpts[i].isCollateral) {\\n                proofs[i] = Proof(false, false, 0);\\n            } else {\\n                (int256 amount0, int256 amount1) = getAmounts(\\n                    omitLPT(position, i),\\n                    uint160(TickMath.getSqrtRatioAtTick(position.lpts[i].lowerTick))\\n                );\\n\\n                int24 tick = TickMath.getTickAtSqrtRatio(\\n                    isMarginZero\\n                        ? getSqrtPriceForAmount1(\\n                            uint256(amount1),\\n                            TickMath.getSqrtRatioAtTick(position.lpts[i].lowerTick),\\n                            position.lpts[i].liquidity\\n                        )\\n                        : getSqrtPriceForAmount0(\\n                            uint256(amount0),\\n                            TickMath.getSqrtRatioAtTick(position.lpts[i].upperTick),\\n                            position.lpts[i].liquidity\\n                        )\\n                );\\n\\n                {\\n                    int24 a = tick / 10;\\n                    int24 b = tick % 10;\\n                    tick = a * 10;\\n                    if (b >= 5) {\\n                        tick += 10;\\n                    }\\n                }\\n\\n                bool isMin = position.lpts[i].lowerTick <= tick && tick <= position.lpts[i].upperTick;\\n                proofs[i] = Proof(true, isMin, tick);\\n            }\\n        }\\n\\n        return proofs;\\n    }\\n\\n    function omitLPT(Position memory position, uint256 target) internal pure returns (Position memory) {\\n        LPT[] memory lpts = new LPT[](position.lpts.length - 1);\\n        uint256 j = 0;\\n\\n        for (uint256 i = 0; i < position.lpts.length; i++) {\\n            if (i == target) continue;\\n            lpts[j] = position.lpts[i];\\n            j++;\\n        }\\n\\n        return Position(position.collateral0, position.collateral1, position.debt0, position.debt1, lpts);\\n    }\\n\\n    function getSqrtPriceForAmount0(\\n        uint256 amount0,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint160) {\\n        return\\n            uint160(\\n                FullMath.mulDiv(\\n                    uint256(liquidity) << FixedPoint96.RESOLUTION,\\n                    sqrtRatioBX96,\\n                    (amount0 * sqrtRatioBX96 + uint256(liquidity)) << FixedPoint96.RESOLUTION\\n                )\\n            );\\n    }\\n\\n    function getSqrtPriceForAmount1(\\n        uint256 amount1,\\n        uint160 sqrtRatioAX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint160) {\\n        return uint160(FullMath.mulDiv(amount1, FixedPoint96.Q96, liquidity) + sqrtRatioAX96);\\n    }\\n}\\n\",\"keccak256\":\"0xedbadf618697844f4d15423c0256d4bc6961d8bfbeb8b6d64a6cafd8bc1813cf\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162002b0f38038062002b0f8339810160408190526200003491620000b9565b600062000040620000b5565b600080546001600160a01b0319166001600160a01b0383169081178255604051929350917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350600180546001600160a01b0319166001600160a01b039290921691909117905560c8600255620000e9565b3390565b600060208284031215620000cb578081fd5b81516001600160a01b0381168114620000e2578182fd5b9392505050565b612a1680620000f96000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80638da5cb5b116100665780638da5cb5b146101215780638fa17fc314610129578063a2ae33681461014b578063ef0fb5581461015e578063f2fde38b146101715761009e565b806316f0115b146100a35780632d79e454146100c157806342cde4e8146100e2578063477bd52d146100f7578063715018a614610117575b600080fd5b6100ab610184565b6040516100b891906126f2565b60405180910390f35b6100d46100cf36600461260c565b610193565b6040516100b8929190612787565b6100ea610819565b6040516100b8919061277e565b61010a61010536600461250d565b61081f565b6040516100b89190612706565b61011f610834565b005b6100ab6108f2565b61013c6101373660046125ba565b610901565b6040516100b89392919061286d565b6100d461015936600461255d565b6109a8565b61011f61016c366004612452565b6109c0565b61011f61017f36600461241a565b6109c5565b6001546001600160a01b031681565b805160408082015182516060808501516020860151600154928801519551635ce20ffb60e01b815260009788979096860395938303946001600160a01b031693635ce20ffb936101e8938d93906004016128cc565b600060405180830381600087803b15801561020257600080fd5b505af1158015610216573d6000803e3d6000fd5b505060015460408087015160608801519151631b7d736f60e11b81526001600160a01b0390931694506336fae6de9350610255928c92906004016128b6565b600060405180830381600087803b15801561026f57600080fd5b505af1158015610283573d6000803e3d6000fd5b5050505060005b8360800151518110156104c657836080015181815181106102a757fe5b602002602001015160000151156103bd576001546080850151805160009283926001600160a01b039091169163e7ebf0bd918d91879081106102e557fe5b6020026020010151604001518960800151878151811061030157fe5b6020026020010151606001518a60800151888151811061031d57fe5b6020026020010151602001516040518563ffffffff1660e01b8152600401610348949392919061288e565b6040805180830381600087803b15801561036157600080fd5b505af1158015610375573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061039991906126cf565b90925090506103a88583610ad9565b94506103b48482610ad9565b935050506104be565b6001546080850151805160009283926001600160a01b039091169163aa763556918d91879081106103ea57fe5b6020026020010151604001518960800151878151811061040657fe5b6020026020010151606001518a60800151888151811061042257fe5b6020026020010151602001516040518563ffffffff1660e01b815260040161044d949392919061288e565b6040805180830381600087803b15801561046657600080fd5b505af115801561047a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061049e91906126cf565b90925090506104ad8583610b3e565b94506104b98482610b3e565b935050505b60010161028a565b5085606001516105eb5760015460405163eb02c30160e01b81526105e9916001600160a01b03169063eb02c30190610502908b9060040161277e565b60006040518083038186803b15801561051a57600080fd5b505afa15801561052e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610556919081019061246a565b8760200151600160009054906101000a90046001600160a01b03166001600160a01b031663517ede9d6040518163ffffffff1660e01b815260040160206040518083038186803b1580156105a957600080fd5b505afa1580156105bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e19190612436565b600254610ba3565b505b6000821380156105fb5750600081125b156106e65760015460408088015190516349b7323960e01b81526000926001600160a01b0316916349b7323991610639918591889190600401612766565b602060405180830381600087803b15801561065357600080fd5b505af1158015610667573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061068b91906125a2565b90507f41c6c6f66ef544ee7b2ce95c6001fe7bd8cf797242d43805ac5006d92a4a3a4488848360006040516106c394939291906128cc565b60405180910390a160006106d982848303610f14565b9550955050505050610812565b6000811380156106f65750600082125b156107e4576001805460408089015190516349b7323960e01b81526000936001600160a01b03909316926349b732399261073592879190600401612766565b602060405180830381600087803b15801561074f57600080fd5b505af1158015610763573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078791906125a2565b90507f41c6c6f66ef544ee7b2ce95c6001fe7bd8cf797242d43805ac5006d92a4a3a4488828460016040516107bf94939291906128cc565b60405180910390a16107d5816000859003610f14565b60009550955050505050610812565b600081121580156107f6575060008212155b156108075790935091506108129050565b600080945094505050505b9250929050565b60025481565b606061082b8383610f71565b90505b92915050565b61083c6111dd565b6001600160a01b031661084d6108f2565b6001600160a01b0316146108a8576040805162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015290519081900360640190fd5b600080546040516001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080546001600160a01b0319169055565b6000546001600160a01b031690565b6000806000610998600160009054906101000a90046001600160a01b03166001600160a01b031663517ede9d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561095757600080fd5b505afa15801561096b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061098f9190612436565b888888886111e1565b9250925092509450945094915050565b6000806109b58484611230565b915091509250929050565b600255565b6109cd6111dd565b6001600160a01b03166109de6108f2565b6001600160a01b031614610a39576040805162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015290519081900360640190fd5b6001600160a01b038116610a7e5760405162461bcd60e51b81526004018080602001828103825260268152602001806129766026913960400191505060405180910390fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000828201818312801590610aee5750838112155b80610b035750600083128015610b0357508381125b61082b5760405162461bcd60e51b815260040180806020018281038252602181526020018061299c6021913960400191505060405180910390fd5b6000818303818312801590610b535750838113155b80610b685750600083128015610b6857508381135b61082b5760405162461bcd60e51b81526004018080602001828103825260248152602001806129bd6024913960400191505060405180910390fd5b600084608001515160001415610bbb57506000610f0c565b835185608001515114610be95760405162461bcd60e51b8152600401610be090612795565b60405180910390fd5b610bf2856112fc565b5060005b8451811015610e5257848181518110610c0b57fe5b60200260200101516000015115610e255785608001518181518110610c2c57fe5b60200260200101516000015115610c555760405162461bcd60e51b8152600401610be0906127e6565b848181518110610c6157fe5b60200260200101516020015115610db357848181518110610c7e57fe5b60200260200101516040015160020b86608001518281518110610c9d57fe5b60200260200101516040015160020b13158015610cf2575085608001518181518110610cc557fe5b60200260200101516060015160020b858281518110610ce057fe5b60200260200101516040015160020b13155b610d0e5760405162461bcd60e51b8152600401610be09061281c565b6000610d3287878481518110610d2057fe5b602002602001015160400151876113b8565b9050808460000313158015610d475750838113155b610d635760405162461bcd60e51b8152600401610be090612801565b6000610d8f88610d89898681518110610d7857fe5b6020026020010151604001516113e8565b8861171a565b1215610dad5760405162461bcd60e51b8152600401610be0906127cb565b50610e20565b6000610ddb8788608001518481518110610dc957fe5b602002602001015160600151876113b8565b610e018889608001518581518110610def57fe5b602002602001015160400151886113b8565b021215610e205760405162461bcd60e51b8152600401610be0906127b0565b610e4a565b85608001518181518110610e3557fe5b602002602001015160000151610e4a57600080fd5b600101610bf6565b508215610eb35781600003610e678685611778565b1215610e855760405162461bcd60e51b8152600401610be090612837565b81610e9086856117c2565b1315610eae5760405162461bcd60e51b8152600401610be090612852565b610f08565b81610ebe8685611778565b1315610edc5760405162461bcd60e51b8152600401610be090612837565b81600003610eea86856117c2565b1215610f085760405162461bcd60e51b8152600401610be090612852565b5060015b949350505050565b600082821115610f6b576040805162461bcd60e51b815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b50900390565b606082608001515167ffffffffffffffff81118015610f8f57600080fd5b50604051908082528060200260200182016040528015610fc957816020015b610fb66120bb565b815260200190600190039081610fae5790505b50905060005b8360800151518110156111d65783608001518181518110610fec57fe5b60200260200101516000015115611038576040805160608101825260008082526020820181905291810191909152825183908390811061102857fe5b60200260200101819052506111ce565b6000806110606110488785611805565b61105b88608001518681518110610d7857fe5b611230565b9150915060006110f9866110bc576110b7846110968a60800151888151811061108557fe5b6020026020010151606001516113e8565b8a6080015188815181106110a657fe5b602002602001015160200151611909565b6110f4565b6110f4836110d38a608001518881518110610d7857fe5b8a6080015188815181106110e357fe5b602002602001015160200151611949565b611976565b90506000600a8260020b8161110a57fe5b0590506000600a8360020b8161111c57fe5b07905081600a02925060058160020b1261113757600a830192505b505060008160020b8860800151868151811061114f57fe5b60200260200101516040015160020b1315801561118d57508760800151858151811061117757fe5b60200260200101516060015160020b8260020b13155b9050604051806060016040528060011515815260200182151581526020018360020b8152508686815181106111be57fe5b6020026020010181905250505050505b600101610fcf565b5092915050565b3390565b600080600087156112165761120b6000886111fb876113e8565b6112048a6113e8565b8989611c95565b925092509250611225565b61120b8760006111fb886113e8565b955095509592505050565b60008060005b8460800151518110156112d8576000806112918661125d89608001518681518110610d7857fe5b6112708a60800151878151811061108557fe5b8a60800151878151811061128057fe5b602002602001015160200151611ce7565b91509150866080015183815181106112a557fe5b602002602001015160000151156112c35793810193928301926112ce565b818503945080840393505b5050600101611236565b50835160208501516040860151606090960151939091019490940394930103919050565b6000620d89b319815b8360800151518110156113b1578360800151818151811061132257fe5b60200260200101516060015160020b8460800151828151811061134157fe5b60200260200101516040015160020b1261135a57600080fd5b8360800151818151811061136a57fe5b60200260200101516040015160020b8260020b131561138857600080fd5b8360800151818151811061139857fe5b6020908102919091010151606001519150600101611305565b5050919050565b60008060006113ca8661105b876113e8565b9150915083156113dd5791506113e19050565b5090505b9392505050565b60008060008360020b126113ff578260020b611407565b8260020b6000035b9050620d89e8811115611445576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b60006001821661145957600160801b61146b565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff169050600282161561149f576ffff97272373d413259a46990580e213a0260801c5b60048216156114be576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b60088216156114dd576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b60108216156114fc576fffcb9843d60f6159c9db58835c9266440260801c5b602082161561151b576fff973b41fa98c081472e6896dfb254c00260801c5b604082161561153a576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615611559576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615611579576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615611599576ff987a7253ac413176f2b074cf7815e540260801c5b6104008216156115b9576ff3392b0822b70005940c7a398e4b70f30260801c5b6108008216156115d9576fe7159475a2c29b7443b29c7fa6e889d90260801c5b6110008216156115f9576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615611619576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615611639576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615611659576f31be135f97d08fd981231505542fcfa60260801c5b6201000082161561167a576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b6202000082161561169a576e5d6af8dedb81196699c329225ee6040260801c5b620400008216156116b9576d2216e584f5fa1ea926041bedfe980260801c5b620800008216156116d6576b048a170391f7dc42444e8fa20260801c5b60008460020b13156116f15780600019816116ed57fe5b0490505b640100000000810615611705576001611708565b60005b60ff16602082901c0192505050919050565b60008061172f846001600160a01b0316611d83565b905060008061173e8787611230565b91509150841561175f57670de0b6b3a76400009202919091050190506113e1565b80670de0b6b3a7640000838502050193505050506113e1565b60008260800151516000141561179b57611794836000846113b8565b905061082e565b61082b8384608001516000815181106117b057fe5b602002602001015160400151846113b8565b6000826080015151600014156117de57611794836000846113b8565b61082b8384608001516000815181106117f357fe5b602002602001015160600151846113b8565b61180d6120db565b600060018460800151510367ffffffffffffffff8111801561182e57600080fd5b5060405190808252806020026020018201604052801561186857816020015b61185561210a565b81526020019060019003908161184d5790505b5090506000805b8560800151518110156118c75784811415611889576118bf565b8560800151818151811061189957fe5b60200260200101518383815181106118ad57fe5b60209081029190910101526001909101905b60010161186f565b506040518060a0016040528086600001518152602001866020015181526020018660400151815260200186606001518152602001838152509250505092915050565b6000610f0c606083811b6fffffffffffffffffffffffffffffffff60601b16906001600160a01b038616906001600160801b03861688830201901b611de1565b6000826001600160a01b031661196d85600160601b856001600160801b0316611de1565b01949350505050565b60006401000276a36001600160a01b038316108015906119b2575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038316105b6119e7576040805162461bcd60e51b81526020600482015260016024820152602960f91b604482015290519081900360640190fd5b640100000000600160c01b03602083901b166001600160801b03811160071b81811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c97908811961790941790921717909117171760808110611a7b57607f810383901c9150611a85565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b14611c8657886001600160a01b0316611c6a826113e8565b6001600160a01b03161115611c7f5781611c81565b805b611c88565b815b9998505050505050505050565b6000806000611cb787611ca7876113e8565b611cb0876113e8565b8c8c611e90565b9250611cd586611cc6876113e8565b611ccf876113e8565b86611ce7565b939a9099509297509195505050505050565b600080836001600160a01b0316856001600160a01b03161115611d08579293925b846001600160a01b0316866001600160a01b031611611d3357611d2c858585611f54565b9150611d7a565b836001600160a01b0316866001600160a01b03161015611d6c57611d58868585611f54565b9150611d65858785611fbd565b9050611d7a565b611d77858585611fbd565b90505b94509492505050565b60006001600160601b81611d98858084611de1565b0281611da057fe5b0491506ec097ce7bc90715b34b9f1000000000821115611dd1576ec097ce7bc90715b34b9f10000000009150611ddb565b81611ddb57600191505b50919050565b6000808060001985870986860292508281109083900303905080611e175760008411611e0c57600080fd5b5082900490506113e1565b808411611e2357600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b6000836001600160a01b0316856001600160a01b03161115611eb0579293925b846001600160a01b0316866001600160a01b031611611edb57611ed4858585612000565b9050611f4b565b836001600160a01b0316866001600160a01b03161015611f3d576000611f02878686612000565b90506000611f11878986612063565b9050806001600160801b0316826001600160801b031610611f325780611f34565b815b92505050611f4b565b611f48858584612063565b90505b95945050505050565b6000826001600160a01b0316846001600160a01b03161115611f74579192915b836001600160a01b0316611fad606060ff16846001600160801b0316901b8686036001600160a01b0316866001600160a01b0316611de1565b81611fb457fe5b04949350505050565b6000826001600160a01b0316846001600160a01b03161115611fdd579192915b610f0c826001600160801b03168585036001600160a01b0316600160601b611de1565b6000826001600160a01b0316846001600160a01b03161115612020579192915b6000612043856001600160a01b0316856001600160a01b0316600160601b611de1565b9050611f4b61205e84838888036001600160a01b0316611de1565b6120a0565b6000826001600160a01b0316846001600160a01b03161115612083579192915b610f0c61205e83600160601b8787036001600160a01b0316611de1565b806001600160801b03811681146120b657600080fd5b919050565b604080516060810182526000808252602082018190529181019190915290565b6040518060a0016040528060008152602001600081526020016000815260200160008152602001606081525090565b60408051608081018252600080825260208201819052918101829052606081019190915290565b600082601f830112612141578081fd5b815160206121566121518361290d565b6128e9565b82815281810190858301608080860288018501891015612174578687fd5b865b868110156122065781838b03121561218c578788fd5b6040805183810181811067ffffffffffffffff821117156121a957fe5b825284516121b681612943565b8152848801516121c581612960565b81890152848201516121d681612951565b80838301525060609150818501516121ed81612951565b9181019190915285529385019391810191600101612176565b509198975050505050505050565b600082601f830112612224578081fd5b813560206122346121518361290d565b82815281810190858301606080860288018501891015612252578687fd5b865b868110156122065781838b03121561226a578788fd5b6040805183810181811067ffffffffffffffff8211171561228757fe5b8252843561229481612943565b8152848801356122a381612943565b81890152848201356122b481612951565b9181019190915285529385019391810191600101612254565b80356120b681612943565b600060a082840312156122e9578081fd5b6040805160a0810167ffffffffffffffff828210818311171561230857fe5b818452829450853583526020915081860135828401528386013584840152606086013560608401526080808701358281111561234357600080fd5b8701601f8101891361235457600080fd5b80356123626121518261290d565b81815285810190838701858402850188018d101561237f57600080fd5b60009450845b848110156124045786828f03121561239b578586fd5b8a518781018181108a821117156123ae57fe5b8c5282356123bb81612943565b8152828a01356123ca81612960565b818b0152828c01356123db81612951565b818d015260608301356123ed81612951565b606082015284529288019290860190600101612385565b5050808589015250505050505050505092915050565b60006020828403121561242b578081fd5b813561082b8161292b565b600060208284031215612447578081fd5b815161082b81612943565b600060208284031215612463578081fd5b5035919050565b60006020828403121561247b578081fd5b815167ffffffffffffffff80821115612492578283fd5b9083019060a082860312156124a5578283fd5b60405160a0810181811083821117156124ba57fe5b8060405250825181526020830151602082015260408301516040820152606083015160608201526080830151828111156124f2578485fd5b6124fe87828601612131565b60808301525095945050505050565b6000806040838503121561251f578081fd5b823567ffffffffffffffff811115612535578182fd5b612541858286016122d8565b925050602083013561255281612943565b809150509250929050565b6000806040838503121561256f578182fd5b823567ffffffffffffffff811115612585578283fd5b612591858286016122d8565b92505060208301356125528161292b565b6000602082840312156125b3578081fd5b5051919050565b600080600080608085870312156125cf578182fd5b8435935060208501356125e181612951565b925060408501356125f181612951565b9150606085013561260181612951565b939692955090935050565b6000806040838503121561261e578182fd5b82359150602083013567ffffffffffffffff8082111561263c578283fd5b908401906080828703121561264f578283fd5b60405160808101818110838211171561266457fe5b604052823582811115612675578485fd5b612681888286016122d8565b825250602083013582811115612695578485fd5b6126a188828601612214565b602083015250604083013560408201526126bd606084016122cd565b60608201528093505050509250929050565b600080604083850312156126e1578182fd5b505080516020909101519092909150565b6001600160a01b0391909116815260200190565b602080825282518282018190526000919060409081850190868401855b828110156127595781518051151585528681015115158786015285015160020b8585015260609093019290850190600101612723565b5091979650505050505050565b92151583526020830191909152604082015260600190565b90815260200190565b918252602082015260400190565b6020808252600190820152600360fc1b604082015260600190565b6020808252600190820152600d60fa1b604082015260600190565b6020808252600190820152603360f81b604082015260600190565b6020808252600190820152603760f81b604082015260600190565b6020808252600190820152601960f91b604082015260600190565b6020808252600190820152603160f81b604082015260600190565b6020808252600190820152603560f81b604082015260600190565b6020808252600190820152601b60f91b604082015260600190565b6001600160801b039390931683526020830191909152604082015260600190565b938452600292830b6020850152910b60408301526001600160801b0316606082015260800190565b9283526020830191909152604082015260600190565b938452602084019290925260408301521515606082015260800190565b60405181810167ffffffffffffffff8111828210171561290557fe5b604052919050565b600067ffffffffffffffff82111561292157fe5b5060209081020190565b6001600160a01b038116811461294057600080fd5b50565b801515811461294057600080fd5b8060020b811461294057600080fd5b6001600160801b038116811461294057600080fdfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573735369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a264697066735822122098932615bdfa45b4c50c6b8fedeb560df781f2bea34f2393d4b9817e494cdf8064736f6c63430007060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c80638da5cb5b116100665780638da5cb5b146101215780638fa17fc314610129578063a2ae33681461014b578063ef0fb5581461015e578063f2fde38b146101715761009e565b806316f0115b146100a35780632d79e454146100c157806342cde4e8146100e2578063477bd52d146100f7578063715018a614610117575b600080fd5b6100ab610184565b6040516100b891906126f2565b60405180910390f35b6100d46100cf36600461260c565b610193565b6040516100b8929190612787565b6100ea610819565b6040516100b8919061277e565b61010a61010536600461250d565b61081f565b6040516100b89190612706565b61011f610834565b005b6100ab6108f2565b61013c6101373660046125ba565b610901565b6040516100b89392919061286d565b6100d461015936600461255d565b6109a8565b61011f61016c366004612452565b6109c0565b61011f61017f36600461241a565b6109c5565b6001546001600160a01b031681565b805160408082015182516060808501516020860151600154928801519551635ce20ffb60e01b815260009788979096860395938303946001600160a01b031693635ce20ffb936101e8938d93906004016128cc565b600060405180830381600087803b15801561020257600080fd5b505af1158015610216573d6000803e3d6000fd5b505060015460408087015160608801519151631b7d736f60e11b81526001600160a01b0390931694506336fae6de9350610255928c92906004016128b6565b600060405180830381600087803b15801561026f57600080fd5b505af1158015610283573d6000803e3d6000fd5b5050505060005b8360800151518110156104c657836080015181815181106102a757fe5b602002602001015160000151156103bd576001546080850151805160009283926001600160a01b039091169163e7ebf0bd918d91879081106102e557fe5b6020026020010151604001518960800151878151811061030157fe5b6020026020010151606001518a60800151888151811061031d57fe5b6020026020010151602001516040518563ffffffff1660e01b8152600401610348949392919061288e565b6040805180830381600087803b15801561036157600080fd5b505af1158015610375573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061039991906126cf565b90925090506103a88583610ad9565b94506103b48482610ad9565b935050506104be565b6001546080850151805160009283926001600160a01b039091169163aa763556918d91879081106103ea57fe5b6020026020010151604001518960800151878151811061040657fe5b6020026020010151606001518a60800151888151811061042257fe5b6020026020010151602001516040518563ffffffff1660e01b815260040161044d949392919061288e565b6040805180830381600087803b15801561046657600080fd5b505af115801561047a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061049e91906126cf565b90925090506104ad8583610b3e565b94506104b98482610b3e565b935050505b60010161028a565b5085606001516105eb5760015460405163eb02c30160e01b81526105e9916001600160a01b03169063eb02c30190610502908b9060040161277e565b60006040518083038186803b15801561051a57600080fd5b505afa15801561052e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610556919081019061246a565b8760200151600160009054906101000a90046001600160a01b03166001600160a01b031663517ede9d6040518163ffffffff1660e01b815260040160206040518083038186803b1580156105a957600080fd5b505afa1580156105bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105e19190612436565b600254610ba3565b505b6000821380156105fb5750600081125b156106e65760015460408088015190516349b7323960e01b81526000926001600160a01b0316916349b7323991610639918591889190600401612766565b602060405180830381600087803b15801561065357600080fd5b505af1158015610667573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061068b91906125a2565b90507f41c6c6f66ef544ee7b2ce95c6001fe7bd8cf797242d43805ac5006d92a4a3a4488848360006040516106c394939291906128cc565b60405180910390a160006106d982848303610f14565b9550955050505050610812565b6000811380156106f65750600082125b156107e4576001805460408089015190516349b7323960e01b81526000936001600160a01b03909316926349b732399261073592879190600401612766565b602060405180830381600087803b15801561074f57600080fd5b505af1158015610763573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078791906125a2565b90507f41c6c6f66ef544ee7b2ce95c6001fe7bd8cf797242d43805ac5006d92a4a3a4488828460016040516107bf94939291906128cc565b60405180910390a16107d5816000859003610f14565b60009550955050505050610812565b600081121580156107f6575060008212155b156108075790935091506108129050565b600080945094505050505b9250929050565b60025481565b606061082b8383610f71565b90505b92915050565b61083c6111dd565b6001600160a01b031661084d6108f2565b6001600160a01b0316146108a8576040805162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015290519081900360640190fd5b600080546040516001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080546001600160a01b0319169055565b6000546001600160a01b031690565b6000806000610998600160009054906101000a90046001600160a01b03166001600160a01b031663517ede9d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561095757600080fd5b505afa15801561096b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061098f9190612436565b888888886111e1565b9250925092509450945094915050565b6000806109b58484611230565b915091509250929050565b600255565b6109cd6111dd565b6001600160a01b03166109de6108f2565b6001600160a01b031614610a39576040805162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015290519081900360640190fd5b6001600160a01b038116610a7e5760405162461bcd60e51b81526004018080602001828103825260268152602001806129766026913960400191505060405180910390fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000828201818312801590610aee5750838112155b80610b035750600083128015610b0357508381125b61082b5760405162461bcd60e51b815260040180806020018281038252602181526020018061299c6021913960400191505060405180910390fd5b6000818303818312801590610b535750838113155b80610b685750600083128015610b6857508381135b61082b5760405162461bcd60e51b81526004018080602001828103825260248152602001806129bd6024913960400191505060405180910390fd5b600084608001515160001415610bbb57506000610f0c565b835185608001515114610be95760405162461bcd60e51b8152600401610be090612795565b60405180910390fd5b610bf2856112fc565b5060005b8451811015610e5257848181518110610c0b57fe5b60200260200101516000015115610e255785608001518181518110610c2c57fe5b60200260200101516000015115610c555760405162461bcd60e51b8152600401610be0906127e6565b848181518110610c6157fe5b60200260200101516020015115610db357848181518110610c7e57fe5b60200260200101516040015160020b86608001518281518110610c9d57fe5b60200260200101516040015160020b13158015610cf2575085608001518181518110610cc557fe5b60200260200101516060015160020b858281518110610ce057fe5b60200260200101516040015160020b13155b610d0e5760405162461bcd60e51b8152600401610be09061281c565b6000610d3287878481518110610d2057fe5b602002602001015160400151876113b8565b9050808460000313158015610d475750838113155b610d635760405162461bcd60e51b8152600401610be090612801565b6000610d8f88610d89898681518110610d7857fe5b6020026020010151604001516113e8565b8861171a565b1215610dad5760405162461bcd60e51b8152600401610be0906127cb565b50610e20565b6000610ddb8788608001518481518110610dc957fe5b602002602001015160600151876113b8565b610e018889608001518581518110610def57fe5b602002602001015160400151886113b8565b021215610e205760405162461bcd60e51b8152600401610be0906127b0565b610e4a565b85608001518181518110610e3557fe5b602002602001015160000151610e4a57600080fd5b600101610bf6565b508215610eb35781600003610e678685611778565b1215610e855760405162461bcd60e51b8152600401610be090612837565b81610e9086856117c2565b1315610eae5760405162461bcd60e51b8152600401610be090612852565b610f08565b81610ebe8685611778565b1315610edc5760405162461bcd60e51b8152600401610be090612837565b81600003610eea86856117c2565b1215610f085760405162461bcd60e51b8152600401610be090612852565b5060015b949350505050565b600082821115610f6b576040805162461bcd60e51b815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b50900390565b606082608001515167ffffffffffffffff81118015610f8f57600080fd5b50604051908082528060200260200182016040528015610fc957816020015b610fb66120bb565b815260200190600190039081610fae5790505b50905060005b8360800151518110156111d65783608001518181518110610fec57fe5b60200260200101516000015115611038576040805160608101825260008082526020820181905291810191909152825183908390811061102857fe5b60200260200101819052506111ce565b6000806110606110488785611805565b61105b88608001518681518110610d7857fe5b611230565b9150915060006110f9866110bc576110b7846110968a60800151888151811061108557fe5b6020026020010151606001516113e8565b8a6080015188815181106110a657fe5b602002602001015160200151611909565b6110f4565b6110f4836110d38a608001518881518110610d7857fe5b8a6080015188815181106110e357fe5b602002602001015160200151611949565b611976565b90506000600a8260020b8161110a57fe5b0590506000600a8360020b8161111c57fe5b07905081600a02925060058160020b1261113757600a830192505b505060008160020b8860800151868151811061114f57fe5b60200260200101516040015160020b1315801561118d57508760800151858151811061117757fe5b60200260200101516060015160020b8260020b13155b9050604051806060016040528060011515815260200182151581526020018360020b8152508686815181106111be57fe5b6020026020010181905250505050505b600101610fcf565b5092915050565b3390565b600080600087156112165761120b6000886111fb876113e8565b6112048a6113e8565b8989611c95565b925092509250611225565b61120b8760006111fb886113e8565b955095509592505050565b60008060005b8460800151518110156112d8576000806112918661125d89608001518681518110610d7857fe5b6112708a60800151878151811061108557fe5b8a60800151878151811061128057fe5b602002602001015160200151611ce7565b91509150866080015183815181106112a557fe5b602002602001015160000151156112c35793810193928301926112ce565b818503945080840393505b5050600101611236565b50835160208501516040860151606090960151939091019490940394930103919050565b6000620d89b319815b8360800151518110156113b1578360800151818151811061132257fe5b60200260200101516060015160020b8460800151828151811061134157fe5b60200260200101516040015160020b1261135a57600080fd5b8360800151818151811061136a57fe5b60200260200101516040015160020b8260020b131561138857600080fd5b8360800151818151811061139857fe5b6020908102919091010151606001519150600101611305565b5050919050565b60008060006113ca8661105b876113e8565b9150915083156113dd5791506113e19050565b5090505b9392505050565b60008060008360020b126113ff578260020b611407565b8260020b6000035b9050620d89e8811115611445576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b60006001821661145957600160801b61146b565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff169050600282161561149f576ffff97272373d413259a46990580e213a0260801c5b60048216156114be576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b60088216156114dd576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b60108216156114fc576fffcb9843d60f6159c9db58835c9266440260801c5b602082161561151b576fff973b41fa98c081472e6896dfb254c00260801c5b604082161561153a576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615611559576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615611579576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615611599576ff987a7253ac413176f2b074cf7815e540260801c5b6104008216156115b9576ff3392b0822b70005940c7a398e4b70f30260801c5b6108008216156115d9576fe7159475a2c29b7443b29c7fa6e889d90260801c5b6110008216156115f9576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615611619576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615611639576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615611659576f31be135f97d08fd981231505542fcfa60260801c5b6201000082161561167a576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b6202000082161561169a576e5d6af8dedb81196699c329225ee6040260801c5b620400008216156116b9576d2216e584f5fa1ea926041bedfe980260801c5b620800008216156116d6576b048a170391f7dc42444e8fa20260801c5b60008460020b13156116f15780600019816116ed57fe5b0490505b640100000000810615611705576001611708565b60005b60ff16602082901c0192505050919050565b60008061172f846001600160a01b0316611d83565b905060008061173e8787611230565b91509150841561175f57670de0b6b3a76400009202919091050190506113e1565b80670de0b6b3a7640000838502050193505050506113e1565b60008260800151516000141561179b57611794836000846113b8565b905061082e565b61082b8384608001516000815181106117b057fe5b602002602001015160400151846113b8565b6000826080015151600014156117de57611794836000846113b8565b61082b8384608001516000815181106117f357fe5b602002602001015160600151846113b8565b61180d6120db565b600060018460800151510367ffffffffffffffff8111801561182e57600080fd5b5060405190808252806020026020018201604052801561186857816020015b61185561210a565b81526020019060019003908161184d5790505b5090506000805b8560800151518110156118c75784811415611889576118bf565b8560800151818151811061189957fe5b60200260200101518383815181106118ad57fe5b60209081029190910101526001909101905b60010161186f565b506040518060a0016040528086600001518152602001866020015181526020018660400151815260200186606001518152602001838152509250505092915050565b6000610f0c606083811b6fffffffffffffffffffffffffffffffff60601b16906001600160a01b038616906001600160801b03861688830201901b611de1565b6000826001600160a01b031661196d85600160601b856001600160801b0316611de1565b01949350505050565b60006401000276a36001600160a01b038316108015906119b2575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038316105b6119e7576040805162461bcd60e51b81526020600482015260016024820152602960f91b604482015290519081900360640190fd5b640100000000600160c01b03602083901b166001600160801b03811160071b81811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c97908811961790941790921717909117171760808110611a7b57607f810383901c9150611a85565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d607f198f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581026f028f6481ab7f045a5af012a19d003aa9198101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b14611c8657886001600160a01b0316611c6a826113e8565b6001600160a01b03161115611c7f5781611c81565b805b611c88565b815b9998505050505050505050565b6000806000611cb787611ca7876113e8565b611cb0876113e8565b8c8c611e90565b9250611cd586611cc6876113e8565b611ccf876113e8565b86611ce7565b939a9099509297509195505050505050565b600080836001600160a01b0316856001600160a01b03161115611d08579293925b846001600160a01b0316866001600160a01b031611611d3357611d2c858585611f54565b9150611d7a565b836001600160a01b0316866001600160a01b03161015611d6c57611d58868585611f54565b9150611d65858785611fbd565b9050611d7a565b611d77858585611fbd565b90505b94509492505050565b60006001600160601b81611d98858084611de1565b0281611da057fe5b0491506ec097ce7bc90715b34b9f1000000000821115611dd1576ec097ce7bc90715b34b9f10000000009150611ddb565b81611ddb57600191505b50919050565b6000808060001985870986860292508281109083900303905080611e175760008411611e0c57600080fd5b5082900490506113e1565b808411611e2357600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b6000836001600160a01b0316856001600160a01b03161115611eb0579293925b846001600160a01b0316866001600160a01b031611611edb57611ed4858585612000565b9050611f4b565b836001600160a01b0316866001600160a01b03161015611f3d576000611f02878686612000565b90506000611f11878986612063565b9050806001600160801b0316826001600160801b031610611f325780611f34565b815b92505050611f4b565b611f48858584612063565b90505b95945050505050565b6000826001600160a01b0316846001600160a01b03161115611f74579192915b836001600160a01b0316611fad606060ff16846001600160801b0316901b8686036001600160a01b0316866001600160a01b0316611de1565b81611fb457fe5b04949350505050565b6000826001600160a01b0316846001600160a01b03161115611fdd579192915b610f0c826001600160801b03168585036001600160a01b0316600160601b611de1565b6000826001600160a01b0316846001600160a01b03161115612020579192915b6000612043856001600160a01b0316856001600160a01b0316600160601b611de1565b9050611f4b61205e84838888036001600160a01b0316611de1565b6120a0565b6000826001600160a01b0316846001600160a01b03161115612083579192915b610f0c61205e83600160601b8787036001600160a01b0316611de1565b806001600160801b03811681146120b657600080fd5b919050565b604080516060810182526000808252602082018190529181019190915290565b6040518060a0016040528060008152602001600081526020016000815260200160008152602001606081525090565b60408051608081018252600080825260208201819052918101829052606081019190915290565b600082601f830112612141578081fd5b815160206121566121518361290d565b6128e9565b82815281810190858301608080860288018501891015612174578687fd5b865b868110156122065781838b03121561218c578788fd5b6040805183810181811067ffffffffffffffff821117156121a957fe5b825284516121b681612943565b8152848801516121c581612960565b81890152848201516121d681612951565b80838301525060609150818501516121ed81612951565b9181019190915285529385019391810191600101612176565b509198975050505050505050565b600082601f830112612224578081fd5b813560206122346121518361290d565b82815281810190858301606080860288018501891015612252578687fd5b865b868110156122065781838b03121561226a578788fd5b6040805183810181811067ffffffffffffffff8211171561228757fe5b8252843561229481612943565b8152848801356122a381612943565b81890152848201356122b481612951565b9181019190915285529385019391810191600101612254565b80356120b681612943565b600060a082840312156122e9578081fd5b6040805160a0810167ffffffffffffffff828210818311171561230857fe5b818452829450853583526020915081860135828401528386013584840152606086013560608401526080808701358281111561234357600080fd5b8701601f8101891361235457600080fd5b80356123626121518261290d565b81815285810190838701858402850188018d101561237f57600080fd5b60009450845b848110156124045786828f03121561239b578586fd5b8a518781018181108a821117156123ae57fe5b8c5282356123bb81612943565b8152828a01356123ca81612960565b818b0152828c01356123db81612951565b818d015260608301356123ed81612951565b606082015284529288019290860190600101612385565b5050808589015250505050505050505092915050565b60006020828403121561242b578081fd5b813561082b8161292b565b600060208284031215612447578081fd5b815161082b81612943565b600060208284031215612463578081fd5b5035919050565b60006020828403121561247b578081fd5b815167ffffffffffffffff80821115612492578283fd5b9083019060a082860312156124a5578283fd5b60405160a0810181811083821117156124ba57fe5b8060405250825181526020830151602082015260408301516040820152606083015160608201526080830151828111156124f2578485fd5b6124fe87828601612131565b60808301525095945050505050565b6000806040838503121561251f578081fd5b823567ffffffffffffffff811115612535578182fd5b612541858286016122d8565b925050602083013561255281612943565b809150509250929050565b6000806040838503121561256f578182fd5b823567ffffffffffffffff811115612585578283fd5b612591858286016122d8565b92505060208301356125528161292b565b6000602082840312156125b3578081fd5b5051919050565b600080600080608085870312156125cf578182fd5b8435935060208501356125e181612951565b925060408501356125f181612951565b9150606085013561260181612951565b939692955090935050565b6000806040838503121561261e578182fd5b82359150602083013567ffffffffffffffff8082111561263c578283fd5b908401906080828703121561264f578283fd5b60405160808101818110838211171561266457fe5b604052823582811115612675578485fd5b612681888286016122d8565b825250602083013582811115612695578485fd5b6126a188828601612214565b602083015250604083013560408201526126bd606084016122cd565b60608201528093505050509250929050565b600080604083850312156126e1578182fd5b505080516020909101519092909150565b6001600160a01b0391909116815260200190565b602080825282518282018190526000919060409081850190868401855b828110156127595781518051151585528681015115158786015285015160020b8585015260609093019290850190600101612723565b5091979650505050505050565b92151583526020830191909152604082015260600190565b90815260200190565b918252602082015260400190565b6020808252600190820152600360fc1b604082015260600190565b6020808252600190820152600d60fa1b604082015260600190565b6020808252600190820152603360f81b604082015260600190565b6020808252600190820152603760f81b604082015260600190565b6020808252600190820152601960f91b604082015260600190565b6020808252600190820152603160f81b604082015260600190565b6020808252600190820152603560f81b604082015260600190565b6020808252600190820152601b60f91b604082015260600190565b6001600160801b039390931683526020830191909152604082015260600190565b938452600292830b6020850152910b60408301526001600160801b0316606082015260800190565b9283526020830191909152604082015260600190565b938452602084019290925260408301521515606082015260800190565b60405181810167ffffffffffffffff8111828210171561290557fe5b604052919050565b600067ffffffffffffffff82111561292157fe5b5060209081020190565b6001600160a01b038116811461294057600080fd5b50565b801515811461294057600080fd5b8060020b811461294057600080fd5b6001600160801b038116811461294057600080fdfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573735369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a264697066735822122098932615bdfa45b4c50c6b8fedeb560df781f2bea34f2393d4b9817e494cdf8064736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 21151,
        "contract": "src/ProductVerifier.sol:ProductVerifier",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 29307,
        "contract": "src/ProductVerifier.sol:ProductVerifier",
        "label": "pool",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IPredyV3Pool)29840"
      },
      {
        "astId": 29309,
        "contract": "src/ProductVerifier.sol:ProductVerifier",
        "label": "threshold",
        "offset": 0,
        "slot": "2",
        "type": "t_int256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IPredyV3Pool)29840": {
        "encoding": "inplace",
        "label": "contract IPredyV3Pool",
        "numberOfBytes": "20"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      }
    }
  }
}
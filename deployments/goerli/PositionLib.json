{
  "address": "0x12B1133A2bF673DE927f6388c4Adb63328c38e50",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "subVaultIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "asset0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "asset1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt1",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "isCollateral",
                  "type": "bool"
                },
                {
                  "internalType": "uint128",
                  "name": "liquidity",
                  "type": "uint128"
                },
                {
                  "internalType": "int24",
                  "name": "lowerTick",
                  "type": "int24"
                },
                {
                  "internalType": "int24",
                  "name": "upperTick",
                  "type": "int24"
                }
              ],
              "internalType": "struct DataType.LPT[]",
              "name": "lpts",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct DataType.Position[]",
          "name": "_positions",
          "type": "tuple[]"
        },
        {
          "internalType": "bool",
          "name": "_isQuoteZero",
          "type": "bool"
        },
        {
          "internalType": "uint24",
          "name": "_feeTier",
          "type": "uint24"
        },
        {
          "internalType": "uint256",
          "name": "_swapRatio",
          "type": "uint256"
        },
        {
          "internalType": "uint160",
          "name": "_sqrtPrice",
          "type": "uint160"
        }
      ],
      "name": "getPositionUpdatesToClose",
      "outputs": [
        {
          "components": [
            {
              "internalType": "enum DataType.PositionUpdateType",
              "name": "positionUpdateType",
              "type": "DataType.PositionUpdateType"
            },
            {
              "internalType": "uint256",
              "name": "subVaultIndex",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "zeroForOne",
              "type": "bool"
            },
            {
              "internalType": "uint128",
              "name": "liquidity",
              "type": "uint128"
            },
            {
              "internalType": "int24",
              "name": "lowerTick",
              "type": "int24"
            },
            {
              "internalType": "int24",
              "name": "upperTick",
              "type": "int24"
            },
            {
              "internalType": "uint256",
              "name": "param0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "param1",
              "type": "uint256"
            }
          ],
          "internalType": "struct DataType.PositionUpdate[]",
          "name": "positionUpdates",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "subVaultIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "asset0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "asset1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt1",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "bool",
                  "name": "isCollateral",
                  "type": "bool"
                },
                {
                  "internalType": "uint128",
                  "name": "liquidity",
                  "type": "uint128"
                },
                {
                  "internalType": "int24",
                  "name": "lowerTick",
                  "type": "int24"
                },
                {
                  "internalType": "int24",
                  "name": "upperTick",
                  "type": "int24"
                }
              ],
              "internalType": "struct DataType.LPT[]",
              "name": "lpts",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct DataType.Position",
          "name": "_position",
          "type": "tuple"
        },
        {
          "internalType": "bool",
          "name": "_isQuoteZero",
          "type": "bool"
        },
        {
          "internalType": "uint24",
          "name": "_feeTier",
          "type": "uint24"
        },
        {
          "internalType": "uint160",
          "name": "_sqrtPrice",
          "type": "uint160"
        }
      ],
      "name": "getPositionUpdatesToOpen",
      "outputs": [
        {
          "components": [
            {
              "internalType": "enum DataType.PositionUpdateType",
              "name": "positionUpdateType",
              "type": "DataType.PositionUpdateType"
            },
            {
              "internalType": "uint256",
              "name": "subVaultIndex",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "zeroForOne",
              "type": "bool"
            },
            {
              "internalType": "uint128",
              "name": "liquidity",
              "type": "uint128"
            },
            {
              "internalType": "int24",
              "name": "lowerTick",
              "type": "int24"
            },
            {
              "internalType": "int24",
              "name": "upperTick",
              "type": "int24"
            },
            {
              "internalType": "uint256",
              "name": "param0",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "param1",
              "type": "uint256"
            }
          ],
          "internalType": "struct DataType.PositionUpdate[]",
          "name": "positionUpdates",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xcb1993519e98506a3d70e6078b17267ceac34e03c8ddd2f545319ceeb8289a43",
  "receipt": {
    "to": null,
    "from": "0x1c745d31A084a14Ba30E7c9F4B14EA762d44f194",
    "contractAddress": "0x12B1133A2bF673DE927f6388c4Adb63328c38e50",
    "transactionIndex": 20,
    "gasUsed": "1466112",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5bc2a9fb914a298e920a49eb394050b8c8d9ca48450025ef4d2c4a2248bd4708",
    "transactionHash": "0xcb1993519e98506a3d70e6078b17267ceac34e03c8ddd2f545319ceeb8289a43",
    "logs": [],
    "blockNumber": 7714316,
    "cumulativeGasUsed": "9127327",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "7b6c5917c3970b2624e355653bd430c7",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subVaultIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"asset0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"asset1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt1\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollateral\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"}],\"internalType\":\"struct DataType.LPT[]\",\"name\":\"lpts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataType.Position[]\",\"name\":\"_positions\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"_isQuoteZero\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"_feeTier\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"_swapRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"_sqrtPrice\",\"type\":\"uint160\"}],\"name\":\"getPositionUpdatesToClose\",\"outputs\":[{\"components\":[{\"internalType\":\"enum DataType.PositionUpdateType\",\"name\":\"positionUpdateType\",\"type\":\"DataType.PositionUpdateType\"},{\"internalType\":\"uint256\",\"name\":\"subVaultIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"param0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param1\",\"type\":\"uint256\"}],\"internalType\":\"struct DataType.PositionUpdate[]\",\"name\":\"positionUpdates\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"subVaultIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"asset0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"asset1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt1\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollateral\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"}],\"internalType\":\"struct DataType.LPT[]\",\"name\":\"lpts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DataType.Position\",\"name\":\"_position\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"_isQuoteZero\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"_feeTier\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"_sqrtPrice\",\"type\":\"uint160\"}],\"name\":\"getPositionUpdatesToOpen\",\"outputs\":[{\"components\":[{\"internalType\":\"enum DataType.PositionUpdateType\",\"name\":\"positionUpdateType\",\"type\":\"DataType.PositionUpdateType\"},{\"internalType\":\"uint256\",\"name\":\"subVaultIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"param0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"param1\",\"type\":\"uint256\"}],\"internalType\":\"struct DataType.PositionUpdate[]\",\"name\":\"positionUpdates\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/libraries/PositionLib.sol\":\"PositionLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363634393436383433373738\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0 <0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = -denominator & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x50e87f7a3197525d1c6f7e04290060e848677c8a4e86c554bc6ace4a4d0d476d\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xe22a1fc7400ae196eba2ad1562d0386462b00a6363b742d55a2fd2021a58586f\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xba085261d44cf28d2583f7c8cdb2f0a6a495ff1a640f86d995ea9d36b42b0046\",\"license\":\"MIT\"},\"lib/v3-core/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(MAX_TICK), 'T');\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    }\\n}\\n\",\"keccak256\":\"0x1f864a2bf61ba05f3173eaf2e3f94c5e1da4bec0554757527b6d1ef1fe439e4e\",\"license\":\"GPL-2.0-or-later\"},\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\\n\\n/// @title Liquidity amount functions\\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\\nlibrary LiquidityAmounts {\\n    /// @notice Downcasts uint256 to uint128\\n    /// @param x The uint258 to be downcasted\\n    /// @return y The passed value, downcasted to uint128\\n    function toUint128(uint256 x) private pure returns (uint128 y) {\\n        require((y = uint128(x)) == x);\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount0 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount0(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount1 The amount1 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount1(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\\n    }\\n\\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount of token0 being sent in\\n    /// @param amount1 The amount of token1 being sent in\\n    /// @return liquidity The maximum amount of liquidity received\\n    function getLiquidityForAmounts(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\n\\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\n        } else {\\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\n        }\\n    }\\n\\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    function getAmount0ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return\\n            FullMath.mulDiv(\\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\\n                sqrtRatioBX96 - sqrtRatioAX96,\\n                sqrtRatioBX96\\n            ) / sqrtRatioAX96;\\n    }\\n\\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount1 The amount of token1\\n    function getAmount1ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n    }\\n\\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    /// @return amount1 The amount of token1\\n    function getAmountsForLiquidity(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\n        } else {\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf149581d28e1c81736dfe72be73ee1301d4945340cc6282fcdd63fe3c85abf24\",\"license\":\"GPL-2.0-or-later\"},\"src/libraries/BaseToken.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\nimport \\\"./PredyMath.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\nlibrary BaseToken {\\n    using SafeMath for uint256;\\n\\n    enum InterestType {\\n        EMPTY,\\n        COMPOUND,\\n        NORMAL\\n    }\\n\\n    struct TokenState {\\n        uint256 totalCompoundDeposited;\\n        uint256 totalCompoundBorrowed;\\n        uint256 totalNormalDeposited;\\n        uint256 totalNormalBorrowed;\\n        uint256 assetScaler;\\n        uint256 debtScaler;\\n        uint256 assetGrowth;\\n        uint256 debtGrowth;\\n    }\\n\\n    struct AccountState {\\n        InterestType interestType;\\n        uint256 assetAmount;\\n        uint256 debtAmount;\\n        uint256 lastAssetGrowth;\\n        uint256 lastDebtGrowth;\\n    }\\n\\n    function initialize(TokenState storage tokenState) internal {\\n        tokenState.assetScaler = Constants.ONE;\\n        tokenState.debtScaler = Constants.ONE;\\n    }\\n\\n    function addAsset(\\n        TokenState storage tokenState,\\n        AccountState storage accountState,\\n        uint256 _amount,\\n        bool _isCompound\\n    ) internal returns (uint256 mintAmount) {\\n        if (_amount == 0) {\\n            return 0;\\n        }\\n\\n        if (_isCompound) {\\n            require(accountState.interestType != InterestType.NORMAL, \\\"B1\\\");\\n            mintAmount = PredyMath.mulDiv(_amount, Constants.ONE, tokenState.assetScaler);\\n\\n            accountState.assetAmount = accountState.assetAmount.add(mintAmount);\\n            tokenState.totalCompoundDeposited = tokenState.totalCompoundDeposited.add(mintAmount);\\n\\n            accountState.interestType = InterestType.COMPOUND;\\n        } else {\\n            require(accountState.interestType != InterestType.COMPOUND, \\\"B2\\\");\\n\\n            accountState.lastAssetGrowth = (\\n                accountState.lastAssetGrowth.mul(accountState.assetAmount).add(tokenState.assetGrowth.mul(_amount))\\n            ).div(accountState.assetAmount.add(_amount));\\n\\n            accountState.assetAmount += _amount;\\n            tokenState.totalNormalDeposited += _amount;\\n\\n            accountState.interestType = InterestType.NORMAL;\\n        }\\n    }\\n\\n    function addDebt(\\n        TokenState storage tokenState,\\n        AccountState storage accountState,\\n        uint256 _amount,\\n        bool _isCompound\\n    ) internal returns (uint256 mintAmount) {\\n        if (_amount == 0) {\\n            return 0;\\n        }\\n\\n        require(getAvailableCollateralValue(tokenState) >= _amount, \\\"B0\\\");\\n\\n        if (_isCompound) {\\n            require(accountState.interestType != InterestType.NORMAL, \\\"B1\\\");\\n            mintAmount = PredyMath.mulDiv(_amount, Constants.ONE, tokenState.debtScaler);\\n\\n            accountState.debtAmount = accountState.debtAmount.add(mintAmount);\\n            tokenState.totalCompoundBorrowed = tokenState.totalCompoundBorrowed.add(mintAmount);\\n\\n            accountState.interestType = InterestType.COMPOUND;\\n        } else {\\n            require(accountState.interestType != InterestType.COMPOUND, \\\"B2\\\");\\n\\n            accountState.lastDebtGrowth = (\\n                accountState.lastDebtGrowth.mul(accountState.debtAmount).add(tokenState.debtGrowth.mul(_amount))\\n            ).div(accountState.debtAmount.add(_amount));\\n\\n            accountState.debtAmount += _amount;\\n            tokenState.totalNormalBorrowed += _amount;\\n\\n            accountState.interestType = InterestType.NORMAL;\\n        }\\n    }\\n\\n    function removeAsset(\\n        TokenState storage tokenState,\\n        AccountState storage accountState,\\n        uint256 _amount\\n    ) internal returns (uint256 finalBurnAmount, uint256 fee) {\\n        if (_amount == 0) {\\n            return (0, 0);\\n        }\\n\\n        if (accountState.interestType == InterestType.COMPOUND) {\\n            uint256 burnAmount = PredyMath.mulDiv(_amount, Constants.ONE, tokenState.assetScaler);\\n\\n            if (accountState.assetAmount < burnAmount) {\\n                finalBurnAmount = accountState.assetAmount;\\n                accountState.assetAmount = 0;\\n            } else {\\n                finalBurnAmount = burnAmount;\\n                accountState.assetAmount = accountState.assetAmount.sub(burnAmount);\\n            }\\n\\n            tokenState.totalCompoundDeposited = tokenState.totalCompoundDeposited.sub(finalBurnAmount);\\n\\n            // TODO: roundUp\\n            finalBurnAmount = PredyMath.mulDiv(finalBurnAmount, tokenState.assetScaler, Constants.ONE);\\n        } else {\\n            fee = getAssetFee(tokenState, accountState);\\n\\n            if (accountState.assetAmount < _amount) {\\n                finalBurnAmount = accountState.assetAmount;\\n                accountState.assetAmount = 0;\\n            } else {\\n                finalBurnAmount = _amount;\\n                fee = (fee * finalBurnAmount) / accountState.assetAmount;\\n                accountState.assetAmount = accountState.assetAmount.sub(_amount);\\n            }\\n\\n            tokenState.totalNormalDeposited = tokenState.totalNormalDeposited.sub(finalBurnAmount);\\n        }\\n    }\\n\\n    function removeDebt(\\n        TokenState storage tokenState,\\n        AccountState storage accountState,\\n        uint256 _amount\\n    ) internal returns (uint256 finalBurnAmount, uint256 fee) {\\n        if (_amount == 0) {\\n            return (0, 0);\\n        }\\n\\n        if (accountState.interestType == InterestType.COMPOUND) {\\n            uint256 burnAmount = PredyMath.mulDiv(_amount, Constants.ONE, tokenState.debtScaler);\\n\\n            if (accountState.debtAmount < burnAmount) {\\n                finalBurnAmount = accountState.debtAmount;\\n                accountState.debtAmount = 0;\\n            } else {\\n                finalBurnAmount = burnAmount;\\n                accountState.debtAmount = accountState.debtAmount.sub(burnAmount);\\n            }\\n\\n            tokenState.totalCompoundBorrowed = tokenState.totalCompoundBorrowed.sub(finalBurnAmount);\\n\\n            // TODO: roundUp\\n            finalBurnAmount = PredyMath.mulDiv(finalBurnAmount, tokenState.debtScaler, Constants.ONE);\\n        } else {\\n            fee = getDebtFee(tokenState, accountState);\\n\\n            if (accountState.debtAmount < _amount) {\\n                finalBurnAmount = accountState.debtAmount;\\n                accountState.debtAmount = 0;\\n            } else {\\n                finalBurnAmount = _amount;\\n                fee = (fee * finalBurnAmount) / accountState.debtAmount;\\n                accountState.debtAmount = accountState.debtAmount.sub(_amount);\\n            }\\n\\n            tokenState.totalNormalBorrowed = tokenState.totalNormalBorrowed.sub(finalBurnAmount);\\n        }\\n    }\\n\\n    function getAssetFee(TokenState memory tokenState, AccountState memory accountState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (accountState.interestType != InterestType.NORMAL) {\\n            return 0;\\n        }\\n\\n        return\\n            PredyMath.mulDiv(\\n                tokenState.assetGrowth.sub(accountState.lastAssetGrowth),\\n                accountState.assetAmount,\\n                Constants.ONE\\n            );\\n    }\\n\\n    function getDebtFee(TokenState memory tokenState, AccountState memory accountState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (accountState.interestType != InterestType.NORMAL) {\\n            return 0;\\n        }\\n\\n        return\\n            PredyMath.mulDiv(\\n                tokenState.debtGrowth.sub(accountState.lastDebtGrowth),\\n                accountState.debtAmount,\\n                Constants.ONE\\n            );\\n    }\\n\\n    // get collateral value\\n    function getAssetValue(TokenState memory tokenState, AccountState memory accountState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (accountState.interestType == InterestType.COMPOUND) {\\n            return PredyMath.mulDiv(accountState.assetAmount, tokenState.assetScaler, Constants.ONE);\\n        } else {\\n            return accountState.assetAmount;\\n        }\\n    }\\n\\n    // get debt value\\n    function getDebtValue(TokenState memory tokenState, AccountState memory accountState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (accountState.interestType == InterestType.COMPOUND) {\\n            return PredyMath.mulDiv(accountState.debtAmount, tokenState.debtScaler, Constants.ONE);\\n        } else {\\n            return accountState.debtAmount;\\n        }\\n    }\\n\\n    // update scaler\\n    function updateScaler(TokenState storage tokenState, uint256 _interestRate) internal returns (uint256) {\\n        if (tokenState.totalCompoundDeposited == 0 && tokenState.totalNormalDeposited == 0) {\\n            return 0;\\n        }\\n\\n        uint256 protocolFee = PredyMath.mulDiv(\\n            PredyMath.mulDiv(_interestRate, getTotalDebtValue(tokenState), Constants.ONE),\\n            Constants.RESERVE_FACTOR,\\n            Constants.ONE\\n        );\\n\\n        // suppry interest rate is InterestRate * Utilization * (1 - ReserveFactor)\\n        uint256 suppryInterestRate = PredyMath.mulDiv(\\n            PredyMath.mulDiv(_interestRate, getTotalDebtValue(tokenState), getTotalCollateralValue(tokenState)),\\n            Constants.ONE - Constants.RESERVE_FACTOR,\\n            Constants.ONE\\n        );\\n\\n        // round up\\n        tokenState.debtScaler = PredyMath.mulDivUp(\\n            tokenState.debtScaler,\\n            (Constants.ONE.add(_interestRate)),\\n            Constants.ONE\\n        );\\n        tokenState.debtGrowth = tokenState.debtGrowth.add(_interestRate);\\n        tokenState.assetScaler = PredyMath.mulDiv(\\n            tokenState.assetScaler,\\n            Constants.ONE + suppryInterestRate,\\n            Constants.ONE\\n        );\\n        tokenState.assetGrowth = tokenState.assetGrowth.add(suppryInterestRate);\\n\\n        return protocolFee;\\n    }\\n\\n    function getTotalCollateralValue(TokenState memory tokenState) internal pure returns (uint256) {\\n        return\\n            PredyMath.mulDiv(tokenState.totalCompoundDeposited, tokenState.assetScaler, Constants.ONE) +\\n            tokenState.totalNormalDeposited;\\n    }\\n\\n    function getTotalDebtValue(TokenState memory tokenState) internal pure returns (uint256) {\\n        return\\n            PredyMath.mulDiv(tokenState.totalCompoundBorrowed, tokenState.debtScaler, Constants.ONE) +\\n            tokenState.totalNormalBorrowed;\\n    }\\n\\n    function getAvailableCollateralValue(TokenState memory tokenState) internal pure returns (uint256) {\\n        return getTotalCollateralValue(tokenState).sub(getTotalDebtValue(tokenState));\\n    }\\n\\n    function getUtilizationRatio(TokenState memory tokenState) internal pure returns (uint256) {\\n        if (tokenState.totalCompoundDeposited == 0 && tokenState.totalNormalBorrowed == 0) {\\n            return Constants.ONE;\\n        }\\n\\n        return PredyMath.mulDiv(getTotalDebtValue(tokenState), Constants.ONE, getTotalCollateralValue(tokenState));\\n    }\\n}\\n\",\"keccak256\":\"0xa4a6e4f3e83985504904672d5ae96363b9e7b129fb480c1a6ec1f0056db2b5ae\",\"license\":\"UNLICENSED\"},\"src/libraries/Constants.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\n\\nlibrary Constants {\\n    uint256 internal constant ONE = 1e18;\\n\\n    // Reserve factor is 10%\\n    uint256 internal constant RESERVE_FACTOR = 10 * 1e16;\\n\\n    // Reserve factor of LPToken is 5%\\n    uint256 internal constant LPT_RESERVE_FACTOR = 5 * 1e16;\\n\\n    // Margin option\\n    int256 internal constant MARGIN_STAY = -1;\\n    int256 internal constant MARGIN_USE = -2;\\n\\n    uint256 internal constant MAX_MARGIN_AMOUNT = 1e32;\\n\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0xee65f6b1332d05927d8bd8fc557fb5b368a0f665caea04acda1cc453372b0201\",\"license\":\"agpl-3.0\"},\"src/libraries/DataType.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\nimport \\\"./PredyMath.sol\\\";\\nimport \\\"./BaseToken.sol\\\";\\n\\nlibrary DataType {\\n    // Storage Data Type\\n    struct PerpStatus {\\n        uint256 tokenId;\\n        int24 lowerTick;\\n        int24 upperTick;\\n        uint128 borrowedLiquidity;\\n        uint256 premiumGrowthForBorrower;\\n        uint256 premiumGrowthForLender;\\n        uint256 fee0Growth;\\n        uint256 fee1Growth;\\n        uint256 lastTouchedTimestamp;\\n    }\\n\\n    struct LPTState {\\n        bool isCollateral;\\n        bytes32 rangeId;\\n        uint128 liquidityAmount;\\n        uint256 premiumGrowthLast;\\n        uint256 fee0Last;\\n        uint256 fee1Last;\\n    }\\n\\n    struct SubVault {\\n        uint256 id;\\n        BaseToken.AccountState balance0;\\n        BaseToken.AccountState balance1;\\n        LPTState[] lpts;\\n    }\\n\\n    struct Vault {\\n        uint256 vaultId;\\n        uint256 marginAmount0;\\n        uint256 marginAmount1;\\n        uint256[] subVaults;\\n    }\\n\\n    struct Context {\\n        address token0;\\n        address token1;\\n        uint24 feeTier;\\n        address positionManager;\\n        address swapRouter;\\n        address uniswapPool;\\n        bool isMarginZero;\\n        uint256 nextSubVaultId;\\n        BaseToken.TokenState tokenState0;\\n        BaseToken.TokenState tokenState1;\\n        uint256 accumuratedProtocolFee0;\\n        uint256 accumuratedProtocolFee1;\\n    }\\n\\n    // Parameters\\n\\n    struct InitializationParams {\\n        uint24 feeTier;\\n        address token0;\\n        address token1;\\n        bool isMarginZero;\\n    }\\n\\n    struct LPT {\\n        bool isCollateral;\\n        uint128 liquidity;\\n        int24 lowerTick;\\n        int24 upperTick;\\n    }\\n\\n    struct Position {\\n        uint256 subVaultIndex;\\n        uint256 asset0;\\n        uint256 asset1;\\n        uint256 debt0;\\n        uint256 debt1;\\n        LPT[] lpts;\\n    }\\n\\n    enum PositionUpdateType {\\n        NOOP,\\n        DEPOSIT_TOKEN,\\n        WITHDRAW_TOKEN,\\n        BORROW_TOKEN,\\n        REPAY_TOKEN,\\n        DEPOSIT_LPT,\\n        WITHDRAW_LPT,\\n        BORROW_LPT,\\n        REPAY_LPT,\\n        SWAP_EXACT_IN,\\n        SWAP_EXACT_OUT,\\n        DEPOSIT_MARGIN,\\n        WITHDRAW_MARGIN\\n    }\\n\\n    struct PositionUpdate {\\n        PositionUpdateType positionUpdateType;\\n        uint256 subVaultIndex;\\n        bool zeroForOne;\\n        uint128 liquidity;\\n        int24 lowerTick;\\n        int24 upperTick;\\n        uint256 param0;\\n        uint256 param1;\\n    }\\n\\n    struct TradeOption {\\n        bool reduceOnly;\\n        bool swapAnyway;\\n        bool quoterMode;\\n        bool isQuoteZero;\\n        int256 targetMarginAmount0;\\n        int256 targetMarginAmount1;\\n        bytes metadata;\\n    }\\n\\n    struct OpenPositionOption {\\n        uint256 lowerSqrtPrice;\\n        uint256 upperSqrtPrice;\\n        uint24 feeTier;\\n    }\\n\\n    struct ClosePositionOption {\\n        uint256 lowerSqrtPrice;\\n        uint256 upperSqrtPrice;\\n        uint256 swapRatio;\\n        uint24 feeTier;\\n    }\\n\\n    struct LiquidationOption {\\n        uint256 lowerSqrtPrice;\\n        uint256 upperSqrtPrice;\\n        uint256 swapRatio;\\n        uint24 feeTier;\\n    }\\n\\n    struct SubVaultValue {\\n        uint256 assetValue;\\n        uint256 debtValue;\\n        int256 premiumValue;\\n    }\\n\\n    struct SubVaultAmount {\\n        uint256 assetAmount0;\\n        uint256 assetAmount1;\\n        uint256 debtAmount0;\\n        uint256 debtAmount1;\\n    }\\n\\n    struct SubVaultInterest {\\n        int256 assetFee0;\\n        int256 assetFee1;\\n        int256 debtFee0;\\n        int256 debtFee1;\\n    }\\n\\n    struct SubVaultPremium {\\n        uint256 receivedTradeAmount0;\\n        uint256 receivedTradeAmount1;\\n        uint256 receivedPremium;\\n        uint256 paidPremium;\\n    }\\n\\n    struct SubVaultStatus {\\n        SubVaultValue values;\\n        SubVaultAmount amount;\\n        SubVaultInterest interest;\\n        SubVaultPremium premium;\\n    }\\n\\n    struct VaultStatus {\\n        int256 positionValue;\\n        int256 marginValue;\\n        int256 minCollateral;\\n        SubVaultStatus[] subVaults;\\n    }\\n}\\n\",\"keccak256\":\"0xf66587f04e9962fbef5190c84762c94faec2a36bde74a7c589365671294d1b3a\",\"license\":\"UNLICENSED\"},\"src/libraries/PositionLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\\\";\\nimport \\\"lib/v3-core/contracts/libraries/TickMath.sol\\\";\\nimport \\\"./DataType.sol\\\";\\n\\nlibrary PositionLib {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    function getPositionUpdatesToOpen(\\n        DataType.Position memory _position,\\n        bool _isQuoteZero,\\n        uint24 _feeTier,\\n        uint160 _sqrtPrice\\n    ) external pure returns (DataType.PositionUpdate[] memory positionUpdates) {\\n        uint256 swapIndex;\\n\\n        (positionUpdates, swapIndex) = calculatePositionUpdatesToOpen(_position);\\n\\n        (int256 requiredAmount0, int256 requiredAmount1) = getRequiredTokenAmountsToOpen(_position, _sqrtPrice);\\n\\n        if (_isQuoteZero) {\\n            if (requiredAmount1 > 0) {\\n                positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.SWAP_EXACT_OUT,\\n                    0,\\n                    true,\\n                    _feeTier,\\n                    0,\\n                    0,\\n                    uint256(requiredAmount1),\\n                    0\\n                );\\n            } else if (requiredAmount1 < 0) {\\n                positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.SWAP_EXACT_IN,\\n                    0,\\n                    false,\\n                    _feeTier,\\n                    0,\\n                    0,\\n                    uint256(-requiredAmount1),\\n                    0\\n                );\\n            }\\n        } else {\\n            if (requiredAmount0 > 0) {\\n                positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.SWAP_EXACT_OUT,\\n                    0,\\n                    false,\\n                    _feeTier,\\n                    0,\\n                    0,\\n                    uint256(requiredAmount0),\\n                    0\\n                );\\n            } else if (requiredAmount0 < 0) {\\n                positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.SWAP_EXACT_IN,\\n                    0,\\n                    true,\\n                    _feeTier,\\n                    0,\\n                    0,\\n                    uint256(-requiredAmount0),\\n                    0\\n                );\\n            }\\n        }\\n    }\\n\\n    function getPositionUpdatesToClose(\\n        DataType.Position[] memory _positions,\\n        bool _isQuoteZero,\\n        uint24 _feeTier,\\n        uint256 _swapRatio,\\n        uint160 _sqrtPrice\\n    ) external pure returns (DataType.PositionUpdate[] memory positionUpdates) {\\n        uint256 swapIndex;\\n\\n        (positionUpdates, swapIndex) = calculatePositionUpdatesToClose(_positions);\\n\\n        (int256 requiredAmount0, int256 requiredAmount1) = getRequiredTokenAmountsToClose(_positions, _sqrtPrice);\\n\\n        if (!_isQuoteZero && requiredAmount0 < 0) {\\n            positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                DataType.PositionUpdateType.SWAP_EXACT_IN,\\n                0,\\n                true,\\n                _feeTier,\\n                0,\\n                0,\\n                (uint256(-requiredAmount0) * _swapRatio) / 100,\\n                0\\n            );\\n        } else if (_isQuoteZero && requiredAmount1 < 0) {\\n            positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                DataType.PositionUpdateType.SWAP_EXACT_IN,\\n                0,\\n                false,\\n                _feeTier,\\n                0,\\n                0,\\n                (uint256(-requiredAmount1) * _swapRatio) / 100,\\n                0\\n            );\\n        }\\n    }\\n\\n    function concat(DataType.Position[] memory _positions, DataType.Position memory _position)\\n        internal\\n        pure\\n        returns (DataType.Position memory)\\n    {\\n        DataType.Position[] memory positions = new DataType.Position[](_positions.length + 1);\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            positions[i] = _positions[i];\\n        }\\n\\n        positions[_positions.length] = _position;\\n\\n        return concat(positions);\\n    }\\n\\n    function concat(DataType.Position[] memory _positions) internal pure returns (DataType.Position memory _position) {\\n        uint256 numLPTs;\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            numLPTs += _positions[i].lpts.length;\\n        }\\n\\n        DataType.LPT[] memory lpts = new DataType.LPT[](numLPTs);\\n\\n        _position = DataType.Position(0, 0, 0, 0, 0, lpts);\\n\\n        uint256 k;\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            _position.asset0 += _positions[i].asset0;\\n            _position.asset1 += _positions[i].asset1;\\n            _position.debt0 += _positions[i].debt0;\\n            _position.debt1 += _positions[i].debt1;\\n\\n            for (uint256 j = 0; j < _positions[i].lpts.length; j++) {\\n                _position.lpts[k] = _positions[i].lpts[j];\\n                k++;\\n            }\\n        }\\n    }\\n\\n    function emptyPosition() internal pure returns (DataType.Position memory) {\\n        DataType.LPT[] memory lpts = new DataType.LPT[](0);\\n        return DataType.Position(0, 0, 0, 0, 0, lpts);\\n    }\\n\\n    /**\\n     * @notice Calculates required token amounts to open position.\\n     * @param _destPosition position to open\\n     * @param _sqrtPrice square root price to calculate\\n     */\\n    function getRequiredTokenAmountsToOpen(DataType.Position memory _destPosition, uint160 _sqrtPrice)\\n        internal\\n        pure\\n        returns (int256, int256)\\n    {\\n        return getRequiredTokenAmounts(emptyPosition(), _destPosition, _sqrtPrice);\\n    }\\n\\n    /**\\n     * @notice Calculates required token amounts to close position.\\n     * @param _srcPosition position to close\\n     * @param _sqrtPrice square root price to calculate\\n     */\\n    function getRequiredTokenAmountsToClose(DataType.Position memory _srcPosition, uint160 _sqrtPrice)\\n        internal\\n        pure\\n        returns (int256, int256)\\n    {\\n        return getRequiredTokenAmounts(_srcPosition, emptyPosition(), _sqrtPrice);\\n    }\\n\\n    function getRequiredTokenAmountsToClose(DataType.Position[] memory _srcPositions, uint160 _sqrtPrice)\\n        internal\\n        pure\\n        returns (int256 requiredAmount0, int256 requiredAmount1)\\n    {\\n        for (uint256 i = 0; i < _srcPositions.length; i++) {\\n            (int256 a0, int256 a1) = getRequiredTokenAmounts(_srcPositions[i], emptyPosition(), _sqrtPrice);\\n            requiredAmount0 += a0;\\n            requiredAmount1 += a1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates required token amounts to update position.\\n     * @param _srcPosition position to update\\n     * @param _destPosition desired position\\n     * @param _sqrtPrice square root price to calculate\\n     */\\n    function getRequiredTokenAmounts(\\n        DataType.Position memory _srcPosition,\\n        DataType.Position memory _destPosition,\\n        uint160 _sqrtPrice\\n    ) internal pure returns (int256 requiredAmount0, int256 requiredAmount1) {\\n        requiredAmount0 = requiredAmount0.sub(int256(_srcPosition.asset0));\\n        requiredAmount1 = requiredAmount1.sub(int256(_srcPosition.asset1));\\n        requiredAmount0 = requiredAmount0.add(int256(_srcPosition.debt0));\\n        requiredAmount1 = requiredAmount1.add(int256(_srcPosition.debt1));\\n\\n        requiredAmount0 = requiredAmount0.add(int256(_destPosition.asset0));\\n        requiredAmount1 = requiredAmount1.add(int256(_destPosition.asset1));\\n        requiredAmount0 = requiredAmount0.sub(int256(_destPosition.debt0));\\n        requiredAmount1 = requiredAmount1.sub(int256(_destPosition.debt1));\\n\\n        for (uint256 i = 0; i < _srcPosition.lpts.length; i++) {\\n            DataType.LPT memory lpt = _srcPosition.lpts[i];\\n\\n            (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\\n                _sqrtPrice,\\n                TickMath.getSqrtRatioAtTick(lpt.lowerTick),\\n                TickMath.getSqrtRatioAtTick(lpt.upperTick),\\n                lpt.liquidity\\n            );\\n\\n            if (lpt.isCollateral) {\\n                requiredAmount0 = requiredAmount0.sub(int256(amount0));\\n                requiredAmount1 = requiredAmount1.sub(int256(amount1));\\n            } else {\\n                requiredAmount0 = requiredAmount0.add(int256(amount0));\\n                requiredAmount1 = requiredAmount1.add(int256(amount1));\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < _destPosition.lpts.length; i++) {\\n            DataType.LPT memory lpt = _destPosition.lpts[i];\\n\\n            (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\\n                _sqrtPrice,\\n                TickMath.getSqrtRatioAtTick(lpt.lowerTick),\\n                TickMath.getSqrtRatioAtTick(lpt.upperTick),\\n                lpt.liquidity\\n            );\\n\\n            if (lpt.isCollateral) {\\n                requiredAmount0 = requiredAmount0.add(int256(amount0));\\n                requiredAmount1 = requiredAmount1.add(int256(amount1));\\n            } else {\\n                requiredAmount0 = requiredAmount0.sub(int256(amount0));\\n                requiredAmount1 = requiredAmount1.sub(int256(amount1));\\n            }\\n        }\\n    }\\n\\n    function calculateLengthOfPositionUpdates(DataType.Position[] memory _positions)\\n        internal\\n        pure\\n        returns (uint256 length)\\n    {\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            length += calculateLengthOfPositionUpdates(_positions[i]);\\n        }\\n    }\\n\\n    function calculateLengthOfPositionUpdates(DataType.Position memory _position)\\n        internal\\n        pure\\n        returns (uint256 length)\\n    {\\n        length = _position.lpts.length;\\n\\n        if (_position.asset0 > 0 || _position.asset1 > 0) {\\n            length += 1;\\n        }\\n\\n        if (_position.debt0 > 0 || _position.debt1 > 0) {\\n            length += 1;\\n        }\\n    }\\n\\n    function calculatePositionUpdatesToOpen(DataType.Position memory _position)\\n        internal\\n        pure\\n        returns (DataType.PositionUpdate[] memory positionUpdates, uint256 swapIndex)\\n    {\\n        positionUpdates = new DataType.PositionUpdate[](calculateLengthOfPositionUpdates(_position) + 1);\\n\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < _position.lpts.length; i++) {\\n            DataType.LPT memory lpt = _position.lpts[i];\\n            if (!lpt.isCollateral) {\\n                positionUpdates[index] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.BORROW_LPT,\\n                    _position.subVaultIndex,\\n                    false,\\n                    lpt.liquidity,\\n                    lpt.lowerTick,\\n                    lpt.upperTick,\\n                    0,\\n                    0\\n                );\\n                index++;\\n            }\\n        }\\n\\n        if (_position.asset0 > 0 || _position.asset1 > 0) {\\n            positionUpdates[index] = DataType.PositionUpdate(\\n                DataType.PositionUpdateType.DEPOSIT_TOKEN,\\n                _position.subVaultIndex,\\n                false,\\n                0,\\n                0,\\n                0,\\n                _position.asset0,\\n                _position.asset1\\n            );\\n            index++;\\n        }\\n\\n        if (_position.debt0 > 0 || _position.debt1 > 0) {\\n            positionUpdates[index] = DataType.PositionUpdate(\\n                DataType.PositionUpdateType.BORROW_TOKEN,\\n                _position.subVaultIndex,\\n                false,\\n                0,\\n                0,\\n                0,\\n                _position.debt0,\\n                _position.debt1\\n            );\\n            index++;\\n        }\\n\\n        swapIndex = index;\\n        index++;\\n\\n        for (uint256 i; i < _position.lpts.length; i++) {\\n            DataType.LPT memory lpt = _position.lpts[i];\\n            if (lpt.isCollateral) {\\n                positionUpdates[index] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.DEPOSIT_LPT,\\n                    _position.subVaultIndex,\\n                    false,\\n                    lpt.liquidity,\\n                    lpt.lowerTick,\\n                    lpt.upperTick,\\n                    0,\\n                    0\\n                );\\n                index++;\\n            }\\n        }\\n    }\\n\\n    function calculatePositionUpdatesToClose(DataType.Position[] memory _positions)\\n        internal\\n        pure\\n        returns (DataType.PositionUpdate[] memory positionUpdates, uint256 swapIndex)\\n    {\\n        positionUpdates = new DataType.PositionUpdate[](calculateLengthOfPositionUpdates(_positions) + 1);\\n\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            for (uint256 j = 0; j < _positions[i].lpts.length; j++) {\\n                DataType.LPT memory lpt = _positions[i].lpts[j];\\n                if (lpt.isCollateral) {\\n                    positionUpdates[index] = DataType.PositionUpdate(\\n                        DataType.PositionUpdateType.WITHDRAW_LPT,\\n                        _positions[i].subVaultIndex,\\n                        false,\\n                        lpt.liquidity,\\n                        lpt.lowerTick,\\n                        lpt.upperTick,\\n                        0,\\n                        0\\n                    );\\n                    index++;\\n                }\\n            }\\n        }\\n\\n        swapIndex = index;\\n        index++;\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            for (uint256 j = 0; j < _positions[i].lpts.length; j++) {\\n                DataType.LPT memory lpt = _positions[i].lpts[j];\\n                if (!lpt.isCollateral) {\\n                    positionUpdates[index] = DataType.PositionUpdate(\\n                        DataType.PositionUpdateType.REPAY_LPT,\\n                        _positions[i].subVaultIndex,\\n                        false,\\n                        lpt.liquidity,\\n                        lpt.lowerTick,\\n                        lpt.upperTick,\\n                        0,\\n                        0\\n                    );\\n                    index++;\\n                }\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            if (_positions[i].asset0 > 0 || _positions[i].asset1 > 0) {\\n                positionUpdates[index] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.WITHDRAW_TOKEN,\\n                    _positions[i].subVaultIndex,\\n                    false,\\n                    0,\\n                    0,\\n                    0,\\n                    _positions[i].asset0,\\n                    _positions[i].asset1\\n                );\\n                index++;\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            if (_positions[i].debt0 > 0 || _positions[i].debt1 > 0) {\\n                positionUpdates[index] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.REPAY_TOKEN,\\n                    _positions[i].subVaultIndex,\\n                    false,\\n                    0,\\n                    0,\\n                    0,\\n                    _positions[i].debt0,\\n                    _positions[i].debt1\\n                );\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc4762e7578595820882ea5576e8fa96dac9e77e3a00799b81439ef9f83353fa8\",\"license\":\"UNLICENSED\"},\"src/libraries/PredyMath.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.4.0 <0.8.0;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\n\\nlibrary PredyMath {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    /**\\n     * @dev https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\\n     */\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\\n     */\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function subReward(uint256 a, uint256 b) internal pure returns (uint256, uint256) {\\n        if (a >= b) {\\n            return (a - b, b);\\n        } else {\\n            return (0, a);\\n        }\\n    }\\n\\n    function addDelta(uint256 x, int256 y) internal pure returns (uint256 z) {\\n        if (y < 0) {\\n            require((z = x - uint256(-y)) < x, \\\"LS\\\");\\n        } else {\\n            require((z = x + uint256(y)) >= x, \\\"LA\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcca04eda0eb9986d39a6064b70238bef8a63e2e4a53ae73dc84d78a082bc8357\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x611991610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c8063886e930014610045578063c257fa161461006e575b600080fd5b61005861005336600461179c565b610081565b604051610065919061181d565b60405180910390f35b61005861007c3660046116d6565b61025c565b6060600061008e86610385565b90925090506000806100a0888661066f565b9150915086156101885760008113156101185760408051610100810190915280600a81526000602082018190526001604083015262ffffff891660608301526080820181905260a0820181905260c0820184905260e090910152845185908590811061010857fe5b6020026020010181905250610183565b60008112156101835760408051610100810190915280600981526000602082018190526040820181905262ffffff891660608301526080820181905260a0820181905283810360c083015260e090910152845185908590811061017757fe5b60200260200101819052505b610251565b60008213156101e65760408051610100810190915280600a81526000602082018190526040820181905262ffffff891660608301526080820181905260a0820181905260c0820185905260e090910152845185908590811061017757fe5b60008212156102515760408051610100810190915280600981526000602082018190526001604083015262ffffff891660608301526080820181905260a0820181905284810360c083015260e090910152845185908590811061024557fe5b60200260200101819052505b505050949350505050565b606060006102698761068f565b909250905060008061027b8986610b1f565b915091508715801561028d5750600082125b156103015760408051610100810190915280600981526000602082018190526001604083015262ffffff8a1660608301526080820181905260a0820181905260c090910190606490859003890204815260200160008152508484815181106102f157fe5b6020026020010181905250610379565b87801561030e5750600081125b156103795760408051610100810182526009815260006020820181905291810182905262ffffff891660608201526080810182905260a08101829052606483830389020460c082015260e0810191909152845185908590811061036d57fe5b60200260200101819052505b50505095945050505050565b6060600061039283610b70565b60010167ffffffffffffffff811180156103ab57600080fd5b506040519080825280602002602001820160405280156103e557816020015b6103d2611471565b8152602001906001900390816103ca5790505b5091506000805b8460a00151518110156104a55760008560a00151828151811061040b57fe5b60200260200101519050806000015161049c5760408051610100810190915280600781526020018760000151815260200160001515815260200182602001516001600160801b03168152602001826040015160020b8152602001826060015160020b815260200160008152602001600081525085848151811061048a57fe5b60209081029190910101526001909201915b506001016103ec565b506000846020015111806104bd575060008460400151115b156105255760408051610100810182526001815285516020808301919091526000828401819052606083018190526080830181905260a083015286015160c08201529085015160e0820152835184908390811061051657fe5b60209081029190910101526001015b60008460600151118061053c575060008460800151115b156105a5576040805161010081018252600381528551602082015260009181018290526060808201839052608080830184905260a083019390935286015160c08201529085015160e0820152835184908390811061059657fe5b60209081029190910101526001015b90506001810160005b8460a00151518110156106685760008560a0015182815181106105cd57fe5b6020026020010151905080600001511561065f5760408051610100810190915280600581526020018760000151815260200160001515815260200182602001516001600160801b03168152602001826040015160020b8152602001826060015160020b815260200160008152602001600081525085848151811061064d57fe5b60209081029190910101526001909201915b506001016105ae565b5050915091565b60008061068461067d610bba565b8585610c2e565b915091509250929050565b6060600061069c83610e34565b60010167ffffffffffffffff811180156106b557600080fd5b506040519080825280602002602001820160405280156106ef57816020015b6106dc611471565b8152602001906001900390816106d45790505b5091506000805b84518110156107fe5760005b85828151811061070e57fe5b602002602001015160a00151518110156107f557600086838151811061073057fe5b602002602001015160a00151828151811061074757fe5b602002602001015190508060000151156107ec57604080516101008101909152806006815260200188858151811061077b57fe5b602002602001015160000151815260200160001515815260200182602001516001600160801b03168152602001826040015160020b8152602001826060015160020b81526020016000815260200160008152508685815181106107da57fe5b60209081029190910101526001909301925b50600101610702565b506001016106f6565b5090506001810160005b845181101561090f5760005b85828151811061082057fe5b602002602001015160a001515181101561090657600086838151811061084257fe5b602002602001015160a00151828151811061085957fe5b6020026020010151905080600001516108fd57604080516101008101909152806008815260200188858151811061088c57fe5b602002602001015160000151815260200160001515815260200182602001516001600160801b03168152602001826040015160020b8152602001826060015160020b81526020016000815260200160008152508685815181106108eb57fe5b60209081029190910101526001909301925b50600101610814565b50600101610808565b5060005b8451811015610a1a57600085828151811061092a57fe5b60200260200101516020015111806109595750600085828151811061094b57fe5b602002602001015160400151115b15610a1257604080516101008101909152806002815260200186838151811061097e57fe5b602002602001015160000151815260200160001515815260200160006001600160801b03168152602001600060020b8152602001600060020b81526020018683815181106109c857fe5b60200260200101516020015181526020018683815181106109e557fe5b602002602001015160400151815250848381518110610a0057fe5b60209081029190910101526001909101905b600101610913565b5060005b8451811015610668576000858281518110610a3557fe5b6020026020010151606001511180610a6457506000858281518110610a5657fe5b602002602001015160800151115b15610b17576040805161010081019091528060048152602001868381518110610a8957fe5b602002602001015160000151815260200160001515815260200160006001600160801b03168152602001600060020b8152602001600060020b8152602001868381518110610ad357fe5b6020026020010151606001518152602001868381518110610af057fe5b602002602001015160800151815250848381518110610b0b57fe5b60200260200101819052505b600101610a1e565b60008060005b8451811015610b6857600080610b56878481518110610b4057fe5b6020026020010151610b50610bba565b88610c2e565b95019493909301925050600101610b25565b509250929050565b60a0810151516020820151151580610b8c575060008260400151115b15610b95576001015b600082606001511180610bac575060008260800151115b15610bb5576001015b919050565b610bc26114b7565b6040805160008082526020820190925281610bf3565b610be06114ed565b815260200190600190039081610bd85790505b5090506040518060c0016040528060008152602001600081526020016000815260200160008152602001600081526020018281525091505090565b600080610c48856020015183610e6f90919063ffffffff16565b9150610c61856040015182610e6f90919063ffffffff16565b9050610c7a856060015183610edb90919063ffffffff16565b9150610c93856080015182610edb90919063ffffffff16565b9050610cac846020015183610edb90919063ffffffff16565b9150610cc5846040015182610edb90919063ffffffff16565b9050610cde846060015183610e6f90919063ffffffff16565b9150610cf7846080015182610e6f90919063ffffffff16565b905060005b8560a0015151811015610d9d5760008660a001518281518110610d1b57fe5b60200260200101519050600080610d5087610d398560400151610f40565b610d468660600151610f40565b8660200151611272565b8451919350915015610d7957610d668683610e6f565b9550610d728582610e6f565b9450610d92565b610d838683610edb565b9550610d8f8582610edb565b94505b505050600101610cfc565b5060005b8460a0015151811015610e2b5760008560a001518281518110610dc057fe5b60200260200101519050600080610dde87610d398560400151610f40565b8451919350915015610e0757610df48683610edb565b9550610e008582610edb565b9450610e20565b610e118683610e6f565b9550610e1d8582610e6f565b94505b505050600101610da1565b50935093915050565b6000805b8251811015610e6957610e5d838281518110610e5057fe5b6020026020010151610b70565b90910190600101610e38565b50919050565b6000818303818312801590610e845750838113155b80610e995750600083128015610e9957508381135b610ed45760405162461bcd60e51b81526004018080602001828103825260248152602001806119386024913960400191505060405180910390fd5b9392505050565b6000828201818312801590610ef05750838112155b80610f055750600083128015610f0557508381125b610ed45760405162461bcd60e51b81526004018080602001828103825260218152602001806119176021913960400191505060405180910390fd5b60008060008360020b12610f57578260020b610f5f565b8260020b6000035b9050620d89e8811115610f9d576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b600060018216610fb157600160801b610fc3565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff1690506002821615610ff7576ffff97272373d413259a46990580e213a0260801c5b6004821615611016576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615611035576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615611054576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615611073576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615611092576fff2ea16466c96a3843ec78b326b528610260801c5b60808216156110b1576ffe5dee046a99a2a811c461f1969c30530260801c5b6101008216156110d1576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b6102008216156110f1576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615611111576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615611131576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615611151576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615611171576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615611191576f70d869a156d2a1b890bb3df62baf32f70260801c5b6180008216156111b1576f31be135f97d08fd981231505542fcfa60260801c5b620100008216156111d2576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b620200008216156111f2576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615611211576d2216e584f5fa1ea926041bedfe980260801c5b6208000082161561122e576b048a170391f7dc42444e8fa20260801c5b60008460020b131561124957806000198161124557fe5b0490505b64010000000081061561125d576001611260565b60005b60ff16602082901c0192505050919050565b600080836001600160a01b0316856001600160a01b03161115611293579293925b846001600160a01b0316866001600160a01b0316116112be576112b785858561130e565b9150611305565b836001600160a01b0316866001600160a01b031610156112f7576112e386858561130e565b91506112f0858785611377565b9050611305565b611302858585611377565b90505b94509492505050565b6000826001600160a01b0316846001600160a01b0316111561132e579192915b836001600160a01b0316611367606060ff16846001600160801b0316901b8686036001600160a01b0316866001600160a01b03166113c2565b8161136e57fe5b04949350505050565b6000826001600160a01b0316846001600160a01b03161115611397579192915b6113ba826001600160801b03168585036001600160a01b0316600160601b6113c2565b949350505050565b60008080600019858709868602925082811090839003039050806113f857600084116113ed57600080fd5b508290049050610ed4565b80841161140457600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b604080516101008101909152806000815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e09091015290565b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001606081525090565b60408051608081018252600080825260208201819052918101829052606081019190915290565b600082601f830112611524578081fd5b81356020611539611534836118f8565b6118d4565b82815281810190858301608080860288018501891015611557578687fd5b865b868110156115ec5781838b03121561156f578788fd5b6040805183810181811067ffffffffffffffff8211171561158c57fe5b8252611597856115fa565b8152878501356001600160801b03811681146115b1578a8bfd5b818901526115c085830161160a565b82820152606091506115d382860161160a565b9181019190915285529385019391810191600101611559565b509198975050505050505050565b80358015158114610bb557600080fd5b8035600281900b8114610bb557600080fd5b600060c0828403121561162d578081fd5b60405160c0810167ffffffffffffffff828210818311171561164b57fe5b81604052829350843583526020850135602084015260408501356040840152606085013560608401526080850135608084015260a085013591508082111561169257600080fd5b5061169f85828601611514565b60a0830152505092915050565b80356001600160a01b0381168114610bb557600080fd5b803562ffffff81168114610bb557600080fd5b600080600080600060a086880312156116ed578081fd5b853567ffffffffffffffff811115611703578182fd5b8601601f81018813611713578182fd5b80356020611723611534836118f8565b82815281810190848301865b85811015611758576117468e8684358a010161161c565b8452928401929084019060010161172f565b5050809950505061176a818a016115fa565b965050505061177b604087016116c3565b925060608601359150611790608087016116ac565b90509295509295909350565b600080600080608085870312156117b1578384fd5b843567ffffffffffffffff8111156117c7578485fd5b6117d38782880161161c565b9450506117e2602086016115fa565b92506117f0604086016116c3565b91506117fe606086016116ac565b905092959194509250565b60020b9052565b6001600160801b03169052565b602080825282518282018190526000919060409081850190868401855b828110156118c75781518051600d811061185057fe5b855280870151878601528581015115158686015260608082015161187682880182611810565b505060808082015161188a82880182611809565b505060a08082015161189e82880182611809565b505060c0818101519086015260e09081015190850152610100909301929085019060010161183a565b5091979650505050505050565b60405181810167ffffffffffffffff811182821017156118f057fe5b604052919050565b600067ffffffffffffffff82111561190c57fe5b506020908102019056fe5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a2646970667358221220edd78056268561840c09e9fcc6bf5a008d36d07bc349ba7f803399df086dcb1664736f6c63430007060033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c8063886e930014610045578063c257fa161461006e575b600080fd5b61005861005336600461179c565b610081565b604051610065919061181d565b60405180910390f35b61005861007c3660046116d6565b61025c565b6060600061008e86610385565b90925090506000806100a0888661066f565b9150915086156101885760008113156101185760408051610100810190915280600a81526000602082018190526001604083015262ffffff891660608301526080820181905260a0820181905260c0820184905260e090910152845185908590811061010857fe5b6020026020010181905250610183565b60008112156101835760408051610100810190915280600981526000602082018190526040820181905262ffffff891660608301526080820181905260a0820181905283810360c083015260e090910152845185908590811061017757fe5b60200260200101819052505b610251565b60008213156101e65760408051610100810190915280600a81526000602082018190526040820181905262ffffff891660608301526080820181905260a0820181905260c0820185905260e090910152845185908590811061017757fe5b60008212156102515760408051610100810190915280600981526000602082018190526001604083015262ffffff891660608301526080820181905260a0820181905284810360c083015260e090910152845185908590811061024557fe5b60200260200101819052505b505050949350505050565b606060006102698761068f565b909250905060008061027b8986610b1f565b915091508715801561028d5750600082125b156103015760408051610100810190915280600981526000602082018190526001604083015262ffffff8a1660608301526080820181905260a0820181905260c090910190606490859003890204815260200160008152508484815181106102f157fe5b6020026020010181905250610379565b87801561030e5750600081125b156103795760408051610100810182526009815260006020820181905291810182905262ffffff891660608201526080810182905260a08101829052606483830389020460c082015260e0810191909152845185908590811061036d57fe5b60200260200101819052505b50505095945050505050565b6060600061039283610b70565b60010167ffffffffffffffff811180156103ab57600080fd5b506040519080825280602002602001820160405280156103e557816020015b6103d2611471565b8152602001906001900390816103ca5790505b5091506000805b8460a00151518110156104a55760008560a00151828151811061040b57fe5b60200260200101519050806000015161049c5760408051610100810190915280600781526020018760000151815260200160001515815260200182602001516001600160801b03168152602001826040015160020b8152602001826060015160020b815260200160008152602001600081525085848151811061048a57fe5b60209081029190910101526001909201915b506001016103ec565b506000846020015111806104bd575060008460400151115b156105255760408051610100810182526001815285516020808301919091526000828401819052606083018190526080830181905260a083015286015160c08201529085015160e0820152835184908390811061051657fe5b60209081029190910101526001015b60008460600151118061053c575060008460800151115b156105a5576040805161010081018252600381528551602082015260009181018290526060808201839052608080830184905260a083019390935286015160c08201529085015160e0820152835184908390811061059657fe5b60209081029190910101526001015b90506001810160005b8460a00151518110156106685760008560a0015182815181106105cd57fe5b6020026020010151905080600001511561065f5760408051610100810190915280600581526020018760000151815260200160001515815260200182602001516001600160801b03168152602001826040015160020b8152602001826060015160020b815260200160008152602001600081525085848151811061064d57fe5b60209081029190910101526001909201915b506001016105ae565b5050915091565b60008061068461067d610bba565b8585610c2e565b915091509250929050565b6060600061069c83610e34565b60010167ffffffffffffffff811180156106b557600080fd5b506040519080825280602002602001820160405280156106ef57816020015b6106dc611471565b8152602001906001900390816106d45790505b5091506000805b84518110156107fe5760005b85828151811061070e57fe5b602002602001015160a00151518110156107f557600086838151811061073057fe5b602002602001015160a00151828151811061074757fe5b602002602001015190508060000151156107ec57604080516101008101909152806006815260200188858151811061077b57fe5b602002602001015160000151815260200160001515815260200182602001516001600160801b03168152602001826040015160020b8152602001826060015160020b81526020016000815260200160008152508685815181106107da57fe5b60209081029190910101526001909301925b50600101610702565b506001016106f6565b5090506001810160005b845181101561090f5760005b85828151811061082057fe5b602002602001015160a001515181101561090657600086838151811061084257fe5b602002602001015160a00151828151811061085957fe5b6020026020010151905080600001516108fd57604080516101008101909152806008815260200188858151811061088c57fe5b602002602001015160000151815260200160001515815260200182602001516001600160801b03168152602001826040015160020b8152602001826060015160020b81526020016000815260200160008152508685815181106108eb57fe5b60209081029190910101526001909301925b50600101610814565b50600101610808565b5060005b8451811015610a1a57600085828151811061092a57fe5b60200260200101516020015111806109595750600085828151811061094b57fe5b602002602001015160400151115b15610a1257604080516101008101909152806002815260200186838151811061097e57fe5b602002602001015160000151815260200160001515815260200160006001600160801b03168152602001600060020b8152602001600060020b81526020018683815181106109c857fe5b60200260200101516020015181526020018683815181106109e557fe5b602002602001015160400151815250848381518110610a0057fe5b60209081029190910101526001909101905b600101610913565b5060005b8451811015610668576000858281518110610a3557fe5b6020026020010151606001511180610a6457506000858281518110610a5657fe5b602002602001015160800151115b15610b17576040805161010081019091528060048152602001868381518110610a8957fe5b602002602001015160000151815260200160001515815260200160006001600160801b03168152602001600060020b8152602001600060020b8152602001868381518110610ad357fe5b6020026020010151606001518152602001868381518110610af057fe5b602002602001015160800151815250848381518110610b0b57fe5b60200260200101819052505b600101610a1e565b60008060005b8451811015610b6857600080610b56878481518110610b4057fe5b6020026020010151610b50610bba565b88610c2e565b95019493909301925050600101610b25565b509250929050565b60a0810151516020820151151580610b8c575060008260400151115b15610b95576001015b600082606001511180610bac575060008260800151115b15610bb5576001015b919050565b610bc26114b7565b6040805160008082526020820190925281610bf3565b610be06114ed565b815260200190600190039081610bd85790505b5090506040518060c0016040528060008152602001600081526020016000815260200160008152602001600081526020018281525091505090565b600080610c48856020015183610e6f90919063ffffffff16565b9150610c61856040015182610e6f90919063ffffffff16565b9050610c7a856060015183610edb90919063ffffffff16565b9150610c93856080015182610edb90919063ffffffff16565b9050610cac846020015183610edb90919063ffffffff16565b9150610cc5846040015182610edb90919063ffffffff16565b9050610cde846060015183610e6f90919063ffffffff16565b9150610cf7846080015182610e6f90919063ffffffff16565b905060005b8560a0015151811015610d9d5760008660a001518281518110610d1b57fe5b60200260200101519050600080610d5087610d398560400151610f40565b610d468660600151610f40565b8660200151611272565b8451919350915015610d7957610d668683610e6f565b9550610d728582610e6f565b9450610d92565b610d838683610edb565b9550610d8f8582610edb565b94505b505050600101610cfc565b5060005b8460a0015151811015610e2b5760008560a001518281518110610dc057fe5b60200260200101519050600080610dde87610d398560400151610f40565b8451919350915015610e0757610df48683610edb565b9550610e008582610edb565b9450610e20565b610e118683610e6f565b9550610e1d8582610e6f565b94505b505050600101610da1565b50935093915050565b6000805b8251811015610e6957610e5d838281518110610e5057fe5b6020026020010151610b70565b90910190600101610e38565b50919050565b6000818303818312801590610e845750838113155b80610e995750600083128015610e9957508381135b610ed45760405162461bcd60e51b81526004018080602001828103825260248152602001806119386024913960400191505060405180910390fd5b9392505050565b6000828201818312801590610ef05750838112155b80610f055750600083128015610f0557508381125b610ed45760405162461bcd60e51b81526004018080602001828103825260218152602001806119176021913960400191505060405180910390fd5b60008060008360020b12610f57578260020b610f5f565b8260020b6000035b9050620d89e8811115610f9d576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b600060018216610fb157600160801b610fc3565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff1690506002821615610ff7576ffff97272373d413259a46990580e213a0260801c5b6004821615611016576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615611035576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615611054576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615611073576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615611092576fff2ea16466c96a3843ec78b326b528610260801c5b60808216156110b1576ffe5dee046a99a2a811c461f1969c30530260801c5b6101008216156110d1576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b6102008216156110f1576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615611111576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615611131576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615611151576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615611171576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615611191576f70d869a156d2a1b890bb3df62baf32f70260801c5b6180008216156111b1576f31be135f97d08fd981231505542fcfa60260801c5b620100008216156111d2576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b620200008216156111f2576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615611211576d2216e584f5fa1ea926041bedfe980260801c5b6208000082161561122e576b048a170391f7dc42444e8fa20260801c5b60008460020b131561124957806000198161124557fe5b0490505b64010000000081061561125d576001611260565b60005b60ff16602082901c0192505050919050565b600080836001600160a01b0316856001600160a01b03161115611293579293925b846001600160a01b0316866001600160a01b0316116112be576112b785858561130e565b9150611305565b836001600160a01b0316866001600160a01b031610156112f7576112e386858561130e565b91506112f0858785611377565b9050611305565b611302858585611377565b90505b94509492505050565b6000826001600160a01b0316846001600160a01b0316111561132e579192915b836001600160a01b0316611367606060ff16846001600160801b0316901b8686036001600160a01b0316866001600160a01b03166113c2565b8161136e57fe5b04949350505050565b6000826001600160a01b0316846001600160a01b03161115611397579192915b6113ba826001600160801b03168585036001600160a01b0316600160601b6113c2565b949350505050565b60008080600019858709868602925082811090839003039050806113f857600084116113ed57600080fd5b508290049050610ed4565b80841161140457600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b604080516101008101909152806000815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e09091015290565b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001606081525090565b60408051608081018252600080825260208201819052918101829052606081019190915290565b600082601f830112611524578081fd5b81356020611539611534836118f8565b6118d4565b82815281810190858301608080860288018501891015611557578687fd5b865b868110156115ec5781838b03121561156f578788fd5b6040805183810181811067ffffffffffffffff8211171561158c57fe5b8252611597856115fa565b8152878501356001600160801b03811681146115b1578a8bfd5b818901526115c085830161160a565b82820152606091506115d382860161160a565b9181019190915285529385019391810191600101611559565b509198975050505050505050565b80358015158114610bb557600080fd5b8035600281900b8114610bb557600080fd5b600060c0828403121561162d578081fd5b60405160c0810167ffffffffffffffff828210818311171561164b57fe5b81604052829350843583526020850135602084015260408501356040840152606085013560608401526080850135608084015260a085013591508082111561169257600080fd5b5061169f85828601611514565b60a0830152505092915050565b80356001600160a01b0381168114610bb557600080fd5b803562ffffff81168114610bb557600080fd5b600080600080600060a086880312156116ed578081fd5b853567ffffffffffffffff811115611703578182fd5b8601601f81018813611713578182fd5b80356020611723611534836118f8565b82815281810190848301865b85811015611758576117468e8684358a010161161c565b8452928401929084019060010161172f565b5050809950505061176a818a016115fa565b965050505061177b604087016116c3565b925060608601359150611790608087016116ac565b90509295509295909350565b600080600080608085870312156117b1578384fd5b843567ffffffffffffffff8111156117c7578485fd5b6117d38782880161161c565b9450506117e2602086016115fa565b92506117f0604086016116c3565b91506117fe606086016116ac565b905092959194509250565b60020b9052565b6001600160801b03169052565b602080825282518282018190526000919060409081850190868401855b828110156118c75781518051600d811061185057fe5b855280870151878601528581015115158686015260608082015161187682880182611810565b505060808082015161188a82880182611809565b505060a08082015161189e82880182611809565b505060c0818101519086015260e09081015190850152610100909301929085019060010161183a565b5091979650505050505050565b60405181810167ffffffffffffffff811182821017156118f057fe5b604052919050565b600067ffffffffffffffff82111561190c57fe5b506020908102019056fe5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a2646970667358221220edd78056268561840c09e9fcc6bf5a008d36d07bc349ba7f803399df086dcb1664736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
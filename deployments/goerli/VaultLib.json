{
  "address": "0x7A80544d6dD5C4DDaE891c8588EbF6fF91B65b99",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "subVaultIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "subVaultId",
          "type": "uint256"
        }
      ],
      "name": "SubVaultCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "subVaultIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "subVaultId",
          "type": "uint256"
        }
      ],
      "name": "SubVaultRemoved",
      "type": "event"
    }
  ],
  "transactionHash": "0xa1bf143faa0f76ef72abe43b76322cbdeedbe0b414a14cea37a5e097652b7c5d",
  "receipt": {
    "to": null,
    "from": "0x1c745d31A084a14Ba30E7c9F4B14EA762d44f194",
    "contractAddress": "0x7A80544d6dD5C4DDaE891c8588EbF6fF91B65b99",
    "transactionIndex": 24,
    "gasUsed": "3159708",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x734447b0477a4ac0e01e20b34e56f88b454d14218b2db8ab5994a5a44fa3463b",
    "transactionHash": "0xa1bf143faa0f76ef72abe43b76322cbdeedbe0b414a14cea37a5e097652b7c5d",
    "logs": [],
    "blockNumber": 7785870,
    "cumulativeGasUsed": "13070901",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "d76ce5b3e4cb0a1ef8a0e748c6da23da",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subVaultIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subVaultId\",\"type\":\"uint256\"}],\"name\":\"SubVaultCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subVaultIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subVaultId\",\"type\":\"uint256\"}],\"name\":\"SubVaultRemoved\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Error Codes V0: no permission\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/libraries/VaultLib.sol\":\"VaultLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363636303230333433343233\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\",\"keccak256\":\"0x0ba8a9b95a956a4050749c0158e928398c447c91469682ca8a7cc7e77a7fe032\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.0 <0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = -denominator & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x50e87f7a3197525d1c6f7e04290060e848677c8a4e86c554bc6ace4a4d0d476d\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xe22a1fc7400ae196eba2ad1562d0386462b00a6363b742d55a2fd2021a58586f\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xba085261d44cf28d2583f7c8cdb2f0a6a495ff1a640f86d995ea9d36b42b0046\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x79004a1d1471abe87e92c4497acba06d5dfa5b1f3e9894a0991a7c4669c5c02c\",\"license\":\"MIT\"},\"lib/v3-core/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(MAX_TICK), 'T');\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    }\\n}\\n\",\"keccak256\":\"0x1f864a2bf61ba05f3173eaf2e3f94c5e1da4bec0554757527b6d1ef1fe439e4e\",\"license\":\"GPL-2.0-or-later\"},\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport '@uniswap/v3-core/contracts/libraries/FullMath.sol';\\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\\n\\n/// @title Liquidity amount functions\\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\\nlibrary LiquidityAmounts {\\n    /// @notice Downcasts uint256 to uint128\\n    /// @param x The uint258 to be downcasted\\n    /// @return y The passed value, downcasted to uint128\\n    function toUint128(uint256 x) private pure returns (uint128 y) {\\n        require((y = uint128(x)) == x);\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount0 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount0(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\n    }\\n\\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount1 The amount1 being sent in\\n    /// @return liquidity The amount of returned liquidity\\n    function getLiquidityForAmount1(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\\n    }\\n\\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param amount0 The amount of token0 being sent in\\n    /// @param amount1 The amount of token1 being sent in\\n    /// @return liquidity The maximum amount of liquidity received\\n    function getLiquidityForAmounts(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal pure returns (uint128 liquidity) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\n\\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\n        } else {\\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\n        }\\n    }\\n\\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    function getAmount0ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return\\n            FullMath.mulDiv(\\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\\n                sqrtRatioBX96 - sqrtRatioAX96,\\n                sqrtRatioBX96\\n            ) / sqrtRatioAX96;\\n    }\\n\\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount1 The amount of token1\\n    function getAmount1ForLiquidity(\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\\n    }\\n\\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\n    /// pool prices and the prices at the tick boundaries\\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\\n    /// @param liquidity The liquidity being valued\\n    /// @return amount0 The amount of token0\\n    /// @return amount1 The amount of token1\\n    function getAmountsForLiquidity(\\n        uint160 sqrtRatioX96,\\n        uint160 sqrtRatioAX96,\\n        uint160 sqrtRatioBX96,\\n        uint128 liquidity\\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n\\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\n        } else {\\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf149581d28e1c81736dfe72be73ee1301d4945340cc6282fcdd63fe3c85abf24\",\"license\":\"GPL-2.0-or-later\"},\"src/libraries/BaseToken.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\nimport \\\"./PredyMath.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\nlibrary BaseToken {\\n    using SafeMath for uint256;\\n\\n    enum InterestType {\\n        EMPTY,\\n        COMPOUND,\\n        NORMAL\\n    }\\n\\n    struct TokenState {\\n        uint256 totalCompoundDeposited;\\n        uint256 totalCompoundBorrowed;\\n        uint256 totalNormalDeposited;\\n        uint256 totalNormalBorrowed;\\n        uint256 assetScaler;\\n        uint256 debtScaler;\\n        uint256 assetGrowth;\\n        uint256 debtGrowth;\\n    }\\n\\n    struct AccountState {\\n        InterestType interestType;\\n        uint256 assetAmount;\\n        uint256 debtAmount;\\n        uint256 lastAssetGrowth;\\n        uint256 lastDebtGrowth;\\n    }\\n\\n    function initialize(TokenState storage tokenState) internal {\\n        tokenState.assetScaler = Constants.ONE;\\n        tokenState.debtScaler = Constants.ONE;\\n    }\\n\\n    function addAsset(\\n        TokenState storage tokenState,\\n        AccountState storage accountState,\\n        uint256 _amount,\\n        bool _isCompound\\n    ) internal returns (uint256 mintAmount) {\\n        if (_amount == 0) {\\n            return 0;\\n        }\\n\\n        if (_isCompound) {\\n            require(accountState.interestType != InterestType.NORMAL, \\\"B1\\\");\\n            mintAmount = PredyMath.mulDiv(_amount, Constants.ONE, tokenState.assetScaler);\\n\\n            accountState.assetAmount = accountState.assetAmount.add(mintAmount);\\n            tokenState.totalCompoundDeposited = tokenState.totalCompoundDeposited.add(mintAmount);\\n\\n            accountState.interestType = InterestType.COMPOUND;\\n        } else {\\n            require(accountState.interestType != InterestType.COMPOUND, \\\"B2\\\");\\n\\n            accountState.lastAssetGrowth = (\\n                accountState.lastAssetGrowth.mul(accountState.assetAmount).add(tokenState.assetGrowth.mul(_amount))\\n            ).div(accountState.assetAmount.add(_amount));\\n\\n            accountState.assetAmount += _amount;\\n            tokenState.totalNormalDeposited += _amount;\\n\\n            accountState.interestType = InterestType.NORMAL;\\n        }\\n    }\\n\\n    function addDebt(\\n        TokenState storage tokenState,\\n        AccountState storage accountState,\\n        uint256 _amount,\\n        bool _isCompound\\n    ) internal returns (uint256 mintAmount) {\\n        if (_amount == 0) {\\n            return 0;\\n        }\\n\\n        require(getAvailableCollateralValue(tokenState) >= _amount, \\\"B0\\\");\\n\\n        if (_isCompound) {\\n            require(accountState.interestType != InterestType.NORMAL, \\\"B1\\\");\\n            mintAmount = PredyMath.mulDiv(_amount, Constants.ONE, tokenState.debtScaler);\\n\\n            accountState.debtAmount = accountState.debtAmount.add(mintAmount);\\n            tokenState.totalCompoundBorrowed = tokenState.totalCompoundBorrowed.add(mintAmount);\\n\\n            accountState.interestType = InterestType.COMPOUND;\\n        } else {\\n            require(accountState.interestType != InterestType.COMPOUND, \\\"B2\\\");\\n\\n            accountState.lastDebtGrowth = (\\n                accountState.lastDebtGrowth.mul(accountState.debtAmount).add(tokenState.debtGrowth.mul(_amount))\\n            ).div(accountState.debtAmount.add(_amount));\\n\\n            accountState.debtAmount += _amount;\\n            tokenState.totalNormalBorrowed += _amount;\\n\\n            accountState.interestType = InterestType.NORMAL;\\n        }\\n    }\\n\\n    function removeAsset(\\n        TokenState storage tokenState,\\n        AccountState storage accountState,\\n        uint256 _amount\\n    ) internal returns (uint256 finalBurnAmount, uint256 fee) {\\n        if (_amount == 0) {\\n            return (0, 0);\\n        }\\n\\n        if (accountState.interestType == InterestType.COMPOUND) {\\n            uint256 burnAmount = PredyMath.mulDiv(_amount, Constants.ONE, tokenState.assetScaler);\\n\\n            if (accountState.assetAmount < burnAmount) {\\n                finalBurnAmount = accountState.assetAmount;\\n                accountState.assetAmount = 0;\\n            } else {\\n                finalBurnAmount = burnAmount;\\n                accountState.assetAmount = accountState.assetAmount.sub(burnAmount);\\n            }\\n\\n            tokenState.totalCompoundDeposited = tokenState.totalCompoundDeposited.sub(finalBurnAmount);\\n\\n            // TODO: roundUp\\n            finalBurnAmount = PredyMath.mulDiv(finalBurnAmount, tokenState.assetScaler, Constants.ONE);\\n        } else {\\n            fee = getAssetFee(tokenState, accountState);\\n\\n            if (accountState.assetAmount < _amount) {\\n                finalBurnAmount = accountState.assetAmount;\\n                accountState.assetAmount = 0;\\n            } else {\\n                finalBurnAmount = _amount;\\n                fee = (fee * finalBurnAmount) / accountState.assetAmount;\\n                accountState.assetAmount = accountState.assetAmount.sub(_amount);\\n            }\\n\\n            tokenState.totalNormalDeposited = tokenState.totalNormalDeposited.sub(finalBurnAmount);\\n        }\\n    }\\n\\n    function removeDebt(\\n        TokenState storage tokenState,\\n        AccountState storage accountState,\\n        uint256 _amount\\n    ) internal returns (uint256 finalBurnAmount, uint256 fee) {\\n        if (_amount == 0) {\\n            return (0, 0);\\n        }\\n\\n        if (accountState.interestType == InterestType.COMPOUND) {\\n            uint256 burnAmount = PredyMath.mulDiv(_amount, Constants.ONE, tokenState.debtScaler);\\n\\n            if (accountState.debtAmount < burnAmount) {\\n                finalBurnAmount = accountState.debtAmount;\\n                accountState.debtAmount = 0;\\n            } else {\\n                finalBurnAmount = burnAmount;\\n                accountState.debtAmount = accountState.debtAmount.sub(burnAmount);\\n            }\\n\\n            tokenState.totalCompoundBorrowed = tokenState.totalCompoundBorrowed.sub(finalBurnAmount);\\n\\n            // TODO: roundUp\\n            finalBurnAmount = PredyMath.mulDiv(finalBurnAmount, tokenState.debtScaler, Constants.ONE);\\n        } else {\\n            fee = getDebtFee(tokenState, accountState);\\n\\n            if (accountState.debtAmount < _amount) {\\n                finalBurnAmount = accountState.debtAmount;\\n                accountState.debtAmount = 0;\\n            } else {\\n                finalBurnAmount = _amount;\\n                fee = (fee * finalBurnAmount) / accountState.debtAmount;\\n                accountState.debtAmount = accountState.debtAmount.sub(_amount);\\n            }\\n\\n            tokenState.totalNormalBorrowed = tokenState.totalNormalBorrowed.sub(finalBurnAmount);\\n        }\\n    }\\n\\n    function getAssetFee(TokenState memory tokenState, AccountState memory accountState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (accountState.interestType != InterestType.NORMAL) {\\n            return 0;\\n        }\\n\\n        return\\n            PredyMath.mulDiv(\\n                tokenState.assetGrowth.sub(accountState.lastAssetGrowth),\\n                accountState.assetAmount,\\n                Constants.ONE\\n            );\\n    }\\n\\n    function getDebtFee(TokenState memory tokenState, AccountState memory accountState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (accountState.interestType != InterestType.NORMAL) {\\n            return 0;\\n        }\\n\\n        return\\n            PredyMath.mulDiv(\\n                tokenState.debtGrowth.sub(accountState.lastDebtGrowth),\\n                accountState.debtAmount,\\n                Constants.ONE\\n            );\\n    }\\n\\n    // get collateral value\\n    function getAssetValue(TokenState memory tokenState, AccountState memory accountState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (accountState.interestType == InterestType.COMPOUND) {\\n            return PredyMath.mulDiv(accountState.assetAmount, tokenState.assetScaler, Constants.ONE);\\n        } else {\\n            return accountState.assetAmount;\\n        }\\n    }\\n\\n    // get debt value\\n    function getDebtValue(TokenState memory tokenState, AccountState memory accountState)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (accountState.interestType == InterestType.COMPOUND) {\\n            return PredyMath.mulDiv(accountState.debtAmount, tokenState.debtScaler, Constants.ONE);\\n        } else {\\n            return accountState.debtAmount;\\n        }\\n    }\\n\\n    // update scaler\\n    function updateScaler(TokenState storage tokenState, uint256 _interestRate) internal returns (uint256) {\\n        if (tokenState.totalCompoundDeposited == 0 && tokenState.totalNormalDeposited == 0) {\\n            return 0;\\n        }\\n\\n        uint256 protocolFee = PredyMath.mulDiv(\\n            PredyMath.mulDiv(_interestRate, getTotalDebtValue(tokenState), Constants.ONE),\\n            Constants.RESERVE_FACTOR,\\n            Constants.ONE\\n        );\\n\\n        // suppry interest rate is InterestRate * Utilization * (1 - ReserveFactor)\\n        uint256 suppryInterestRate = PredyMath.mulDiv(\\n            PredyMath.mulDiv(_interestRate, getTotalDebtValue(tokenState), getTotalCollateralValue(tokenState)),\\n            Constants.ONE - Constants.RESERVE_FACTOR,\\n            Constants.ONE\\n        );\\n\\n        // round up\\n        tokenState.debtScaler = PredyMath.mulDivUp(\\n            tokenState.debtScaler,\\n            (Constants.ONE.add(_interestRate)),\\n            Constants.ONE\\n        );\\n        tokenState.debtGrowth = tokenState.debtGrowth.add(_interestRate);\\n        tokenState.assetScaler = PredyMath.mulDiv(\\n            tokenState.assetScaler,\\n            Constants.ONE + suppryInterestRate,\\n            Constants.ONE\\n        );\\n        tokenState.assetGrowth = tokenState.assetGrowth.add(suppryInterestRate);\\n\\n        return protocolFee;\\n    }\\n\\n    function getTotalCollateralValue(TokenState memory tokenState) internal pure returns (uint256) {\\n        return\\n            PredyMath.mulDiv(tokenState.totalCompoundDeposited, tokenState.assetScaler, Constants.ONE) +\\n            tokenState.totalNormalDeposited;\\n    }\\n\\n    function getTotalDebtValue(TokenState memory tokenState) internal pure returns (uint256) {\\n        return\\n            PredyMath.mulDiv(tokenState.totalCompoundBorrowed, tokenState.debtScaler, Constants.ONE) +\\n            tokenState.totalNormalBorrowed;\\n    }\\n\\n    function getAvailableCollateralValue(TokenState memory tokenState) internal pure returns (uint256) {\\n        return getTotalCollateralValue(tokenState).sub(getTotalDebtValue(tokenState));\\n    }\\n\\n    function getUtilizationRatio(TokenState memory tokenState) internal pure returns (uint256) {\\n        if (tokenState.totalCompoundDeposited == 0 && tokenState.totalNormalBorrowed == 0) {\\n            return Constants.ONE;\\n        }\\n\\n        return PredyMath.mulDiv(getTotalDebtValue(tokenState), Constants.ONE, getTotalCollateralValue(tokenState));\\n    }\\n}\\n\",\"keccak256\":\"0xa4a6e4f3e83985504904672d5ae96363b9e7b129fb480c1a6ec1f0056db2b5ae\",\"license\":\"UNLICENSED\"},\"src/libraries/Constants.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\n\\nlibrary Constants {\\n    uint256 internal constant ONE = 1e18;\\n\\n    // Reserve factor is 10%\\n    uint256 internal constant RESERVE_FACTOR = 10 * 1e16;\\n\\n    // Reserve factor of LPToken is 5%\\n    uint256 internal constant LPT_RESERVE_FACTOR = 5 * 1e16;\\n\\n    // Margin option\\n    int256 internal constant MARGIN_STAY = -1;\\n    int256 internal constant MARGIN_USE = -2;\\n\\n    uint256 internal constant MAX_MARGIN_AMOUNT = 1e32;\\n    int256 internal constant MIN_MARGIN_AMOUNT = 1e6;\\n\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n\\n    // 2%\\n    uint256 internal constant BASE_MIN_COLLATERAL_WITH_DEBT = 20000;\\n    // 0.00005\\n    uint256 internal constant MIN_COLLATERAL_WITH_DEBT_SLOPE = 50;\\n    // 3% scaled by 1e6\\n    uint256 internal constant BASE_LIQ_SLIPPAGE_SQRT_TOLERANCE = 15000;\\n    // 0.000022\\n    uint256 internal constant LIQ_SLIPPAGE_SQRT_SLOPE = 22;\\n}\\n\",\"keccak256\":\"0xa85e238e6d45f5acf194770d2b8104e807f97346564bbb78939f4658dda64165\",\"license\":\"agpl-3.0\"},\"src/libraries/DataType.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\nimport \\\"./PredyMath.sol\\\";\\nimport \\\"./BaseToken.sol\\\";\\n\\nlibrary DataType {\\n    // Storage Data Type\\n    struct PerpStatus {\\n        int24 lowerTick;\\n        int24 upperTick;\\n        uint128 borrowedLiquidity;\\n        uint256 premiumGrowthForBorrower;\\n        uint256 premiumGrowthForLender;\\n        uint256 fee0Growth;\\n        uint256 fee1Growth;\\n        uint256 lastTouchedTimestamp;\\n    }\\n\\n    struct LPTState {\\n        bool isCollateral;\\n        bytes32 rangeId;\\n        uint128 liquidityAmount;\\n        uint256 premiumGrowthLast;\\n        uint256 fee0Last;\\n        uint256 fee1Last;\\n    }\\n\\n    struct SubVault {\\n        uint256 id;\\n        BaseToken.AccountState balance0;\\n        BaseToken.AccountState balance1;\\n        LPTState[] lpts;\\n    }\\n\\n    struct Vault {\\n        uint256 vaultId;\\n        uint256 marginAmount0;\\n        uint256 marginAmount1;\\n        uint256[] subVaults;\\n    }\\n\\n    struct Context {\\n        address token0;\\n        address token1;\\n        uint24 feeTier;\\n        address swapRouter;\\n        address uniswapPool;\\n        bool isMarginZero;\\n        uint256 nextSubVaultId;\\n        BaseToken.TokenState tokenState0;\\n        BaseToken.TokenState tokenState1;\\n        uint256 accumuratedProtocolFee0;\\n        uint256 accumuratedProtocolFee1;\\n    }\\n\\n    // Parameters\\n\\n    struct InitializationParams {\\n        uint24 feeTier;\\n        address token0;\\n        address token1;\\n        bool isMarginZero;\\n    }\\n\\n    struct LPT {\\n        bool isCollateral;\\n        uint128 liquidity;\\n        int24 lowerTick;\\n        int24 upperTick;\\n    }\\n\\n    struct Position {\\n        uint256 subVaultIndex;\\n        uint256 asset0;\\n        uint256 asset1;\\n        uint256 debt0;\\n        uint256 debt1;\\n        LPT[] lpts;\\n    }\\n\\n    enum PositionUpdateType {\\n        NOOP,\\n        DEPOSIT_TOKEN,\\n        WITHDRAW_TOKEN,\\n        BORROW_TOKEN,\\n        REPAY_TOKEN,\\n        DEPOSIT_LPT,\\n        WITHDRAW_LPT,\\n        BORROW_LPT,\\n        REPAY_LPT,\\n        SWAP_EXACT_IN,\\n        SWAP_EXACT_OUT,\\n        DEPOSIT_MARGIN,\\n        WITHDRAW_MARGIN\\n    }\\n\\n    struct PositionUpdate {\\n        PositionUpdateType positionUpdateType;\\n        uint256 subVaultIndex;\\n        bool zeroForOne;\\n        uint128 liquidity;\\n        int24 lowerTick;\\n        int24 upperTick;\\n        uint256 param0;\\n        uint256 param1;\\n    }\\n\\n    struct TradeOption {\\n        bool reduceOnly;\\n        bool swapAnyway;\\n        bool quoterMode;\\n        bool isQuoteZero;\\n        int256 targetMarginAmount0;\\n        int256 targetMarginAmount1;\\n        bytes metadata;\\n    }\\n\\n    struct OpenPositionOption {\\n        uint256 lowerSqrtPrice;\\n        uint256 upperSqrtPrice;\\n        uint256 deadline;\\n    }\\n\\n    struct ClosePositionOption {\\n        uint256 lowerSqrtPrice;\\n        uint256 upperSqrtPrice;\\n        uint256 swapRatio;\\n        uint256 closeRatio;\\n        uint256 deadline;\\n    }\\n\\n    struct LiquidationOption {\\n        uint256 swapRatio;\\n        uint256 closeRatio;\\n    }\\n\\n    struct SubVaultValue {\\n        uint256 assetValue;\\n        uint256 debtValue;\\n        int256 premiumValue;\\n    }\\n\\n    struct SubVaultAmount {\\n        uint256 assetAmount0;\\n        uint256 assetAmount1;\\n        uint256 debtAmount0;\\n        uint256 debtAmount1;\\n    }\\n\\n    struct SubVaultInterest {\\n        int256 assetFee0;\\n        int256 assetFee1;\\n        int256 debtFee0;\\n        int256 debtFee1;\\n    }\\n\\n    struct SubVaultPremium {\\n        uint256 receivedTradeAmount0;\\n        uint256 receivedTradeAmount1;\\n        uint256 receivedPremium;\\n        uint256 paidPremium;\\n    }\\n\\n    struct SubVaultStatus {\\n        SubVaultValue values;\\n        SubVaultAmount amount;\\n        SubVaultInterest interest;\\n        SubVaultPremium premium;\\n    }\\n\\n    struct VaultStatus {\\n        int256 positionValue;\\n        int256 marginValue;\\n        int256 minCollateral;\\n        SubVaultStatus[] subVaults;\\n    }\\n\\n    struct TokenAmounts {\\n        int256 amount0;\\n        int256 amount1;\\n    }\\n}\\n\",\"keccak256\":\"0x5fc226fb62d87693a9dd4d15544e7f2489ce419ad5e5d2d5f2be64cdbb9d23a8\",\"license\":\"UNLICENSED\"},\"src/libraries/LPTMath.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\\\";\\nimport \\\"lib/v3-core/contracts/libraries/TickMath.sol\\\";\\n\\nlibrary LPTMath {\\n    function getLiquidityAndAmountToDeposit(\\n        bool isMarginZero,\\n        uint256 requestedAmount,\\n        uint160 currentSqrtPrice,\\n        int24 lower,\\n        int24 upper\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        if (isMarginZero) {\\n            return\\n                getLiquidityAndAmount(\\n                    0,\\n                    requestedAmount,\\n                    TickMath.getSqrtRatioAtTick(upper),\\n                    currentSqrtPrice,\\n                    lower,\\n                    upper\\n                );\\n        } else {\\n            return\\n                getLiquidityAndAmount(\\n                    requestedAmount,\\n                    0,\\n                    TickMath.getSqrtRatioAtTick(lower),\\n                    currentSqrtPrice,\\n                    lower,\\n                    upper\\n                );\\n        }\\n    }\\n\\n    function getLiquidityAndAmountToBorrow(\\n        bool isMarginZero,\\n        uint256 requestedAmount,\\n        int24 tick,\\n        int24 lower,\\n        int24 upper\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        if (isMarginZero) {\\n            return\\n                getLiquidityAndAmount(\\n                    0,\\n                    requestedAmount,\\n                    TickMath.getSqrtRatioAtTick(upper),\\n                    TickMath.getSqrtRatioAtTick(tick),\\n                    lower,\\n                    upper\\n                );\\n        } else {\\n            return\\n                getLiquidityAndAmount(\\n                    requestedAmount,\\n                    0,\\n                    TickMath.getSqrtRatioAtTick(lower),\\n                    TickMath.getSqrtRatioAtTick(tick),\\n                    lower,\\n                    upper\\n                );\\n        }\\n    }\\n\\n    function getLiquidityAndAmount(\\n        uint256 requestedAmount0,\\n        uint256 requestedAmount1,\\n        uint160 sqrtPrice1,\\n        uint160 sqrtPrice2,\\n        int24 lower,\\n        int24 upper\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint128 liquidity,\\n            uint256 amount0,\\n            uint256 amount1\\n        )\\n    {\\n        (liquidity) = LiquidityAmounts.getLiquidityForAmounts(\\n            sqrtPrice1,\\n            TickMath.getSqrtRatioAtTick(lower),\\n            TickMath.getSqrtRatioAtTick(upper),\\n            requestedAmount0,\\n            requestedAmount1\\n        );\\n\\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\\n            sqrtPrice2,\\n            TickMath.getSqrtRatioAtTick(lower),\\n            TickMath.getSqrtRatioAtTick(upper),\\n            liquidity\\n        );\\n    }\\n\\n    function getLiquidityForAmounts(\\n        uint160 currentSqrtPrice,\\n        int24 _lower,\\n        int24 _upper,\\n        uint256 _amount0,\\n        uint256 _amount1\\n    ) internal pure returns (uint128) {\\n        return\\n            LiquidityAmounts.getLiquidityForAmounts(\\n                currentSqrtPrice,\\n                TickMath.getSqrtRatioAtTick(_lower),\\n                TickMath.getSqrtRatioAtTick(_upper),\\n                _amount0,\\n                _amount1\\n            );\\n    }\\n\\n    function getAmountsForLiquidity(\\n        uint160 currentSqrtPrice,\\n        int24 _lower,\\n        int24 _upper,\\n        uint128 _liquidity\\n    ) internal pure returns (uint256, uint256) {\\n        return\\n            LiquidityAmounts.getAmountsForLiquidity(\\n                currentSqrtPrice,\\n                TickMath.getSqrtRatioAtTick(_lower),\\n                TickMath.getSqrtRatioAtTick(_upper),\\n                _liquidity\\n            );\\n    }\\n\\n    function getSqrtRatioAtTick(int24 _tick) internal pure returns (uint160) {\\n        return TickMath.getSqrtRatioAtTick(_tick);\\n    }\\n\\n    /**\\n     * if isMarginZero is true, calculates token1 price by token0.\\n     * if isMarginZero is false, calculates token0 price by token1.\\n     * @dev underlying token's decimal must be 1e18.\\n     */\\n    function decodeSqrtPriceX96(bool isMarginZero, uint256 sqrtPriceX96) internal pure returns (uint256 price) {\\n        uint256 scaler = 1e18; //10**ERC20(token0).decimals();\\n\\n        if (isMarginZero) {\\n            price = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint256(2**(96 * 2)) / (scaler));\\n            if (price == 0) return 1e36;\\n            price = 1e36 / price;\\n        } else {\\n            price = (FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint256(2**96)) * scaler) / uint256(2**96);\\n        }\\n\\n        if (price > 1e36) price = 1e36;\\n        else if (price == 0) price = 1;\\n    }\\n}\\n\",\"keccak256\":\"0xffd31b44269715673df8db205319b3a821e4f6c81352f28061426691e8496f62\",\"license\":\"UNLICENSED\"},\"src/libraries/PositionCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\\\";\\nimport \\\"lib/v3-core/contracts/libraries/TickMath.sol\\\";\\nimport \\\"./DataType.sol\\\";\\nimport \\\"./LPTMath.sol\\\";\\n\\n/**\\n * @title PositionCalculator library\\n * @notice Implements the base logic calculating Min. Deposit and value of positions.\\n */\\nlibrary PositionCalculator {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n    // sqrt{1.18} = 1.08627804912\\n    uint160 internal constant UPPER_E8 = 108627805;\\n    // sqrt{1/1.18} = 0.92057461789\\n    uint160 internal constant LOWER_E8 = 92057462;\\n\\n    struct PositionCalculatorParams {\\n        int256 marginAmount0;\\n        int256 marginAmount1;\\n        uint256 asset0;\\n        uint256 asset1;\\n        uint256 debt0;\\n        uint256 debt1;\\n        DataType.LPT[] lpts;\\n    }\\n\\n    /**\\n     * @notice Calculates Min. Deposit for a vault.\\n     * MinDeposit = vaultPositionValue - minValue + Max{0.00006 * Sqrt{DebtValue}, 0.02} * DebtValue\\n     * @param _params position object\\n     * @param _sqrtPrice square root price to calculate\\n     * @param _isMarginZero whether the stable token is token0 or token1\\n     */\\n    function calculateMinDeposit(\\n        PositionCalculatorParams memory _params,\\n        uint160 _sqrtPrice,\\n        bool _isMarginZero\\n    ) internal pure returns (int256 minDeposit) {\\n        int256 vaultPositionValue = calculateValue(_params, _sqrtPrice, _isMarginZero);\\n\\n        int256 minValue = calculateMinValue(_params, _sqrtPrice, _isMarginZero);\\n\\n        (, , uint256 debtValue) = calculateCollateralAndDebtValue(_params, _sqrtPrice, _isMarginZero, false);\\n\\n        minDeposit = int256(calculateRequiredCollateralWithDebt(debtValue).mul(debtValue).div(1e6))\\n            .add(vaultPositionValue)\\n            .sub(minValue);\\n\\n        if (minDeposit < Constants.MIN_MARGIN_AMOUNT && debtValue > 0) {\\n            minDeposit = Constants.MIN_MARGIN_AMOUNT;\\n        }\\n    }\\n\\n    function calculateRequiredCollateralWithDebt(uint256 _debtValue) internal pure returns (uint256) {\\n        return\\n            PredyMath.max(\\n                Constants.MIN_COLLATERAL_WITH_DEBT_SLOPE.mul(PredyMath.sqrt(_debtValue * 1e6)).div(1e6),\\n                Constants.BASE_MIN_COLLATERAL_WITH_DEBT\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates square root of min price (a * b)^(1/4)\\n     * P_{min}^(1/2) = (a * b)^(1/4)\\n     */\\n    function calculateMinSqrtPrice(int24 _lowerTick, int24 _upperTick) internal pure returns (uint160) {\\n        return uint160(TickMath.getSqrtRatioAtTick((_lowerTick + _upperTick) / 2));\\n    }\\n\\n    /**\\n     * @notice Calculates minValue.\\n     * MinValue is minimal value of following values.\\n     * 1. value of at P*1.24\\n     * 2. value of at P/1.24\\n     * 3. values of at P_{min} of LPTs\\n     */\\n    function calculateMinValue(\\n        PositionCalculatorParams memory _position,\\n        uint160 _sqrtPrice,\\n        bool _isMarginZero\\n    ) internal pure returns (int256 minValue) {\\n        minValue = type(int256).max;\\n        uint160 sqrtPriceLower = (LOWER_E8 * _sqrtPrice) / 1e8;\\n        uint160 sqrtPriceUpper = (UPPER_E8 * _sqrtPrice) / 1e8;\\n\\n        require(TickMath.MIN_SQRT_RATIO < _sqrtPrice && _sqrtPrice < TickMath.MAX_SQRT_RATIO, \\\"PC0\\\");\\n\\n        if (sqrtPriceLower < TickMath.MIN_SQRT_RATIO) {\\n            sqrtPriceLower = TickMath.MIN_SQRT_RATIO;\\n        }\\n\\n        if (sqrtPriceUpper > TickMath.MAX_SQRT_RATIO) {\\n            sqrtPriceUpper = TickMath.MAX_SQRT_RATIO;\\n        }\\n\\n        {\\n            // 1. check value of at P*1.24\\n            int256 value = calculateValue(_position, sqrtPriceUpper, _isMarginZero);\\n            if (minValue > value) {\\n                minValue = value;\\n            }\\n        }\\n\\n        {\\n            // 2. check value of at P/1.24\\n            int256 value = calculateValue(_position, sqrtPriceLower, _isMarginZero);\\n            if (minValue > value) {\\n                minValue = value;\\n            }\\n        }\\n\\n        // 3. check values of at P_{min} of LPTs\\n        for (uint256 i = 0; i < _position.lpts.length; i++) {\\n            DataType.LPT memory lpt = _position.lpts[i];\\n\\n            if (!lpt.isCollateral) {\\n                uint160 minSqrtPrice = calculateMinSqrtPrice(lpt.upperTick, lpt.lowerTick);\\n\\n                if (minSqrtPrice < sqrtPriceLower || sqrtPriceUpper < minSqrtPrice) {\\n                    continue;\\n                }\\n\\n                int256 value = calculateValue(_position, minSqrtPrice, _isMarginZero, true);\\n\\n                if (minValue > value) {\\n                    minValue = value;\\n                }\\n            }\\n        }\\n    }\\n\\n    function calculateValue(\\n        PositionCalculatorParams memory _position,\\n        uint160 _sqrtPrice,\\n        bool _isMarginZero\\n    ) internal pure returns (int256 value) {\\n        return calculateValue(_position, _sqrtPrice, _isMarginZero, false);\\n    }\\n\\n    function calculateValue(\\n        PositionCalculatorParams memory _position,\\n        uint160 _sqrtPrice,\\n        bool isMarginZero,\\n        bool _isMinPrice\\n    ) internal pure returns (int256 value) {\\n        (int256 marginValue, uint256 assetValue, uint256 debtValue) = calculateCollateralAndDebtValue(\\n            _position,\\n            _sqrtPrice,\\n            isMarginZero,\\n            _isMinPrice\\n        );\\n\\n        return marginValue + int256(assetValue) - int256(debtValue);\\n    }\\n\\n    function calculateCollateralAndDebtValue(\\n        PositionCalculatorParams memory _position,\\n        uint160 _sqrtPrice,\\n        bool _isMarginZero,\\n        bool _isMinPrice\\n    )\\n        internal\\n        pure\\n        returns (\\n            int256 marginValue,\\n            uint256 assetValue,\\n            uint256 debtValue\\n        )\\n    {\\n        uint256 price = LPTMath.decodeSqrtPriceX96(_isMarginZero, _sqrtPrice);\\n\\n        if (_isMarginZero) {\\n            marginValue = _position.marginAmount0.add(_position.marginAmount1.mul(int256(price)).div(1e18));\\n        } else {\\n            marginValue = _position.marginAmount0.mul(int256(price)).div(1e18).add(_position.marginAmount1);\\n        }\\n\\n        (\\n            uint256 assetAmount0,\\n            uint256 assetAmount1,\\n            uint256 debtAmount0,\\n            uint256 debtAmount1\\n        ) = calculateCollateralAndDebtAmount(_position, _sqrtPrice, _isMinPrice);\\n\\n        if (_isMarginZero) {\\n            assetValue = assetAmount0.add(assetAmount1.mul(price).div(1e18));\\n            debtValue = debtAmount0.add(debtAmount1.mul(price).div(1e18));\\n        } else {\\n            assetValue = assetAmount0.mul(price).div(1e18).add(assetAmount1);\\n            debtValue = debtAmount0.mul(price).div(1e18).add(debtAmount1);\\n        }\\n    }\\n\\n    function calculateCollateralAndDebtAmount(\\n        PositionCalculatorParams memory _position,\\n        uint160 _sqrtPrice,\\n        bool _isMinPrice\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256 assetAmount0,\\n            uint256 assetAmount1,\\n            uint256 debtAmount0,\\n            uint256 debtAmount1\\n        )\\n    {\\n        assetAmount0 = _position.asset0;\\n        assetAmount1 = _position.asset1;\\n        debtAmount0 = _position.debt0;\\n        debtAmount1 = _position.debt1;\\n\\n        for (uint256 i = 0; i < _position.lpts.length; i++) {\\n            DataType.LPT memory lpt = _position.lpts[i];\\n\\n            uint160 sqrtLowerPrice = TickMath.getSqrtRatioAtTick(lpt.lowerTick);\\n            uint160 sqrtUpperPrice = TickMath.getSqrtRatioAtTick(lpt.upperTick);\\n\\n            if (_isMinPrice && !lpt.isCollateral && sqrtLowerPrice <= _sqrtPrice && _sqrtPrice <= sqrtUpperPrice) {\\n                debtAmount1 = debtAmount1.add(\\n                    (\\n                        uint256(lpt.liquidity).mul(\\n                            TickMath.getSqrtRatioAtTick(lpt.upperTick) - TickMath.getSqrtRatioAtTick(lpt.lowerTick)\\n                        )\\n                    ).div(Q96)\\n                );\\n                continue;\\n            }\\n\\n            (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\\n                _sqrtPrice,\\n                sqrtLowerPrice,\\n                sqrtUpperPrice,\\n                lpt.liquidity\\n            );\\n\\n            if (lpt.isCollateral) {\\n                assetAmount0 = assetAmount0.add(amount0);\\n                assetAmount1 = assetAmount1.add(amount1);\\n            } else {\\n                debtAmount0 = debtAmount0.add(amount0);\\n                debtAmount1 = debtAmount1.add(amount1);\\n            }\\n        }\\n    }\\n\\n    function add(PositionCalculatorParams memory _params, DataType.Position memory _position)\\n        internal\\n        pure\\n        returns (PositionCalculatorParams memory _newParams)\\n    {\\n        uint256 numLPTs = _params.lpts.length + _position.lpts.length;\\n\\n        DataType.LPT[] memory lpts = new DataType.LPT[](numLPTs);\\n\\n        _newParams = PositionCalculatorParams(\\n            _params.marginAmount0,\\n            _params.marginAmount1,\\n            _params.asset0,\\n            _params.asset1,\\n            _params.debt0,\\n            _params.debt1,\\n            lpts\\n        );\\n\\n        _newParams.asset0 += _position.asset0;\\n        _newParams.asset1 += _position.asset1;\\n        _newParams.debt0 += _position.debt0;\\n        _newParams.debt1 += _position.debt1;\\n\\n        uint256 k;\\n\\n        for (uint256 j = 0; j < _params.lpts.length; j++) {\\n            _newParams.lpts[k] = _params.lpts[j];\\n            k++;\\n        }\\n        for (uint256 j = 0; j < _position.lpts.length; j++) {\\n            _newParams.lpts[k] = _position.lpts[j];\\n            k++;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2c04d11f21f4141d7f2466d536b24cc7bf4ceed9b4f43d1b6ae3aeabb09d3d2a\",\"license\":\"UNLICENSED\"},\"src/libraries/PositionLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/SafeCast.sol\\\";\\nimport \\\"lib/v3-periphery/contracts/libraries/LiquidityAmounts.sol\\\";\\nimport \\\"lib/v3-core/contracts/libraries/TickMath.sol\\\";\\nimport \\\"./DataType.sol\\\";\\n\\nlibrary PositionLib {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n    using SafeCast for uint256;\\n\\n    function getPositionUpdatesToOpen(\\n        DataType.Position memory _position,\\n        bool _isQuoteZero,\\n        uint160 _sqrtPrice\\n    ) external pure returns (DataType.PositionUpdate[] memory positionUpdates) {\\n        uint256 swapIndex;\\n\\n        (positionUpdates, swapIndex) = calculatePositionUpdatesToOpen(_position);\\n\\n        (int256 requiredAmount0, int256 requiredAmount1) = getRequiredTokenAmountsToOpen(_position, _sqrtPrice);\\n\\n        if (_isQuoteZero) {\\n            if (requiredAmount1 > 0) {\\n                positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.SWAP_EXACT_OUT,\\n                    0,\\n                    true,\\n                    0,\\n                    0,\\n                    0,\\n                    uint256(requiredAmount1),\\n                    0\\n                );\\n            } else if (requiredAmount1 < 0) {\\n                positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.SWAP_EXACT_IN,\\n                    0,\\n                    false,\\n                    0,\\n                    0,\\n                    0,\\n                    uint256(-requiredAmount1),\\n                    0\\n                );\\n            }\\n        } else {\\n            if (requiredAmount0 > 0) {\\n                positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.SWAP_EXACT_OUT,\\n                    0,\\n                    false,\\n                    0,\\n                    0,\\n                    0,\\n                    uint256(requiredAmount0),\\n                    0\\n                );\\n            } else if (requiredAmount0 < 0) {\\n                positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.SWAP_EXACT_IN,\\n                    0,\\n                    true,\\n                    0,\\n                    0,\\n                    0,\\n                    uint256(-requiredAmount0),\\n                    0\\n                );\\n            }\\n        }\\n    }\\n\\n    function getPositionUpdatesToClose(\\n        DataType.Position[] memory _positions,\\n        bool _isQuoteZero,\\n        uint256 _swapRatio,\\n        uint256 _closeRatio,\\n        uint160 _sqrtPrice\\n    ) external pure returns (DataType.PositionUpdate[] memory positionUpdates) {\\n        uint256 swapIndex;\\n\\n        (positionUpdates, swapIndex) = calculatePositionUpdatesToClose(_positions, _closeRatio);\\n\\n        (int256 requiredAmount0, int256 requiredAmount1) = getRequiredTokenAmountsToClose(_positions, _sqrtPrice);\\n\\n        if (!_isQuoteZero && requiredAmount0 < 0) {\\n            positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                DataType.PositionUpdateType.SWAP_EXACT_IN,\\n                0,\\n                true,\\n                0,\\n                0,\\n                0,\\n                (uint256(-requiredAmount0) * _swapRatio) / 100,\\n                0\\n            );\\n        } else if (_isQuoteZero && requiredAmount1 < 0) {\\n            positionUpdates[swapIndex] = DataType.PositionUpdate(\\n                DataType.PositionUpdateType.SWAP_EXACT_IN,\\n                0,\\n                false,\\n                0,\\n                0,\\n                0,\\n                (uint256(-requiredAmount1) * _swapRatio) / 100,\\n                0\\n            );\\n        }\\n    }\\n\\n    function concat(DataType.Position[] memory _positions, DataType.Position memory _position)\\n        internal\\n        pure\\n        returns (DataType.Position memory)\\n    {\\n        DataType.Position[] memory positions = new DataType.Position[](_positions.length + 1);\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            positions[i] = _positions[i];\\n        }\\n\\n        positions[_positions.length] = _position;\\n\\n        return concat(positions);\\n    }\\n\\n    function concat(DataType.Position[] memory _positions) internal pure returns (DataType.Position memory _position) {\\n        uint256 numLPTs;\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            numLPTs += _positions[i].lpts.length;\\n        }\\n\\n        DataType.LPT[] memory lpts = new DataType.LPT[](numLPTs);\\n\\n        _position = DataType.Position(0, 0, 0, 0, 0, lpts);\\n\\n        uint256 k;\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            _position.asset0 += _positions[i].asset0;\\n            _position.asset1 += _positions[i].asset1;\\n            _position.debt0 += _positions[i].debt0;\\n            _position.debt1 += _positions[i].debt1;\\n\\n            for (uint256 j = 0; j < _positions[i].lpts.length; j++) {\\n                _position.lpts[k] = _positions[i].lpts[j];\\n                k++;\\n            }\\n        }\\n    }\\n\\n    function emptyPosition() internal pure returns (DataType.Position memory) {\\n        DataType.LPT[] memory lpts = new DataType.LPT[](0);\\n        return DataType.Position(0, 0, 0, 0, 0, lpts);\\n    }\\n\\n    /**\\n     * @notice Calculates required token amounts to open position.\\n     * @param _destPosition position to open\\n     * @param _sqrtPrice square root price to calculate\\n     */\\n    function getRequiredTokenAmountsToOpen(DataType.Position memory _destPosition, uint160 _sqrtPrice)\\n        internal\\n        pure\\n        returns (int256, int256)\\n    {\\n        return getRequiredTokenAmounts(emptyPosition(), _destPosition, _sqrtPrice);\\n    }\\n\\n    /**\\n     * @notice Calculates required token amounts to close position.\\n     * @param _srcPosition position to close\\n     * @param _sqrtPrice square root price to calculate\\n     */\\n    function getRequiredTokenAmountsToClose(DataType.Position memory _srcPosition, uint160 _sqrtPrice)\\n        internal\\n        pure\\n        returns (int256, int256)\\n    {\\n        return getRequiredTokenAmounts(_srcPosition, emptyPosition(), _sqrtPrice);\\n    }\\n\\n    function getRequiredTokenAmountsToClose(DataType.Position[] memory _srcPositions, uint160 _sqrtPrice)\\n        internal\\n        pure\\n        returns (int256 requiredAmount0, int256 requiredAmount1)\\n    {\\n        for (uint256 i = 0; i < _srcPositions.length; i++) {\\n            (int256 a0, int256 a1) = getRequiredTokenAmounts(_srcPositions[i], emptyPosition(), _sqrtPrice);\\n            requiredAmount0 += a0;\\n            requiredAmount1 += a1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates required token amounts to update position.\\n     * @param _srcPosition position to update\\n     * @param _destPosition desired position\\n     * @param _sqrtPrice square root price to calculate\\n     */\\n    function getRequiredTokenAmounts(\\n        DataType.Position memory _srcPosition,\\n        DataType.Position memory _destPosition,\\n        uint160 _sqrtPrice\\n    ) internal pure returns (int256 requiredAmount0, int256 requiredAmount1) {\\n        requiredAmount0 = requiredAmount0.sub(int256(_srcPosition.asset0));\\n        requiredAmount1 = requiredAmount1.sub(int256(_srcPosition.asset1));\\n        requiredAmount0 = requiredAmount0.add(int256(_srcPosition.debt0));\\n        requiredAmount1 = requiredAmount1.add(int256(_srcPosition.debt1));\\n\\n        requiredAmount0 = requiredAmount0.add(int256(_destPosition.asset0));\\n        requiredAmount1 = requiredAmount1.add(int256(_destPosition.asset1));\\n        requiredAmount0 = requiredAmount0.sub(int256(_destPosition.debt0));\\n        requiredAmount1 = requiredAmount1.sub(int256(_destPosition.debt1));\\n\\n        for (uint256 i = 0; i < _srcPosition.lpts.length; i++) {\\n            DataType.LPT memory lpt = _srcPosition.lpts[i];\\n\\n            (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\\n                _sqrtPrice,\\n                TickMath.getSqrtRatioAtTick(lpt.lowerTick),\\n                TickMath.getSqrtRatioAtTick(lpt.upperTick),\\n                lpt.liquidity\\n            );\\n\\n            if (lpt.isCollateral) {\\n                requiredAmount0 = requiredAmount0.sub(int256(amount0));\\n                requiredAmount1 = requiredAmount1.sub(int256(amount1));\\n            } else {\\n                requiredAmount0 = requiredAmount0.add(int256(amount0));\\n                requiredAmount1 = requiredAmount1.add(int256(amount1));\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < _destPosition.lpts.length; i++) {\\n            DataType.LPT memory lpt = _destPosition.lpts[i];\\n\\n            (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\\n                _sqrtPrice,\\n                TickMath.getSqrtRatioAtTick(lpt.lowerTick),\\n                TickMath.getSqrtRatioAtTick(lpt.upperTick),\\n                lpt.liquidity\\n            );\\n\\n            if (lpt.isCollateral) {\\n                requiredAmount0 = requiredAmount0.add(int256(amount0));\\n                requiredAmount1 = requiredAmount1.add(int256(amount1));\\n            } else {\\n                requiredAmount0 = requiredAmount0.sub(int256(amount0));\\n                requiredAmount1 = requiredAmount1.sub(int256(amount1));\\n            }\\n        }\\n    }\\n\\n    function calculateLengthOfPositionUpdates(DataType.Position[] memory _positions)\\n        internal\\n        pure\\n        returns (uint256 length)\\n    {\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            length += calculateLengthOfPositionUpdates(_positions[i]);\\n        }\\n    }\\n\\n    function calculateLengthOfPositionUpdates(DataType.Position memory _position)\\n        internal\\n        pure\\n        returns (uint256 length)\\n    {\\n        length = _position.lpts.length;\\n\\n        if (_position.asset0 > 0 || _position.asset1 > 0) {\\n            length += 1;\\n        }\\n\\n        if (_position.debt0 > 0 || _position.debt1 > 0) {\\n            length += 1;\\n        }\\n    }\\n\\n    function calculatePositionUpdatesToOpen(DataType.Position memory _position)\\n        internal\\n        pure\\n        returns (DataType.PositionUpdate[] memory positionUpdates, uint256 swapIndex)\\n    {\\n        positionUpdates = new DataType.PositionUpdate[](calculateLengthOfPositionUpdates(_position) + 1);\\n\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < _position.lpts.length; i++) {\\n            DataType.LPT memory lpt = _position.lpts[i];\\n            if (!lpt.isCollateral) {\\n                positionUpdates[index] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.BORROW_LPT,\\n                    _position.subVaultIndex,\\n                    false,\\n                    lpt.liquidity,\\n                    lpt.lowerTick,\\n                    lpt.upperTick,\\n                    0,\\n                    0\\n                );\\n                index++;\\n            }\\n        }\\n\\n        if (_position.asset0 > 0 || _position.asset1 > 0) {\\n            positionUpdates[index] = DataType.PositionUpdate(\\n                DataType.PositionUpdateType.DEPOSIT_TOKEN,\\n                _position.subVaultIndex,\\n                false,\\n                0,\\n                0,\\n                0,\\n                _position.asset0,\\n                _position.asset1\\n            );\\n            index++;\\n        }\\n\\n        if (_position.debt0 > 0 || _position.debt1 > 0) {\\n            positionUpdates[index] = DataType.PositionUpdate(\\n                DataType.PositionUpdateType.BORROW_TOKEN,\\n                _position.subVaultIndex,\\n                false,\\n                0,\\n                0,\\n                0,\\n                _position.debt0,\\n                _position.debt1\\n            );\\n            index++;\\n        }\\n\\n        swapIndex = index;\\n        index++;\\n\\n        for (uint256 i; i < _position.lpts.length; i++) {\\n            DataType.LPT memory lpt = _position.lpts[i];\\n            if (lpt.isCollateral) {\\n                positionUpdates[index] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.DEPOSIT_LPT,\\n                    _position.subVaultIndex,\\n                    false,\\n                    lpt.liquidity,\\n                    lpt.lowerTick,\\n                    lpt.upperTick,\\n                    0,\\n                    0\\n                );\\n                index++;\\n            }\\n        }\\n    }\\n\\n    function calculatePositionUpdatesToClose(DataType.Position[] memory _positions, uint256 _closeRatio)\\n        internal\\n        pure\\n        returns (DataType.PositionUpdate[] memory positionUpdates, uint256 swapIndex)\\n    {\\n        positionUpdates = new DataType.PositionUpdate[](calculateLengthOfPositionUpdates(_positions) + 1);\\n\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            for (uint256 j = 0; j < _positions[i].lpts.length; j++) {\\n                DataType.LPT memory lpt = _positions[i].lpts[j];\\n                if (lpt.isCollateral) {\\n                    positionUpdates[index] = DataType.PositionUpdate(\\n                        DataType.PositionUpdateType.WITHDRAW_LPT,\\n                        _positions[i].subVaultIndex,\\n                        false,\\n                        uint256(lpt.liquidity).mul(_closeRatio).div(1e4).toUint128(),\\n                        lpt.lowerTick,\\n                        lpt.upperTick,\\n                        0,\\n                        0\\n                    );\\n                    index++;\\n                }\\n            }\\n        }\\n\\n        swapIndex = index;\\n        index++;\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            for (uint256 j = 0; j < _positions[i].lpts.length; j++) {\\n                DataType.LPT memory lpt = _positions[i].lpts[j];\\n                if (!lpt.isCollateral) {\\n                    positionUpdates[index] = DataType.PositionUpdate(\\n                        DataType.PositionUpdateType.REPAY_LPT,\\n                        _positions[i].subVaultIndex,\\n                        false,\\n                        uint256(lpt.liquidity).mul(_closeRatio).div(1e4).toUint128(),\\n                        lpt.lowerTick,\\n                        lpt.upperTick,\\n                        0,\\n                        0\\n                    );\\n                    index++;\\n                }\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            if (_positions[i].asset0 > 0 || _positions[i].asset1 > 0) {\\n                positionUpdates[index] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.WITHDRAW_TOKEN,\\n                    _positions[i].subVaultIndex,\\n                    false,\\n                    0,\\n                    0,\\n                    0,\\n                    _positions[i].asset0.mul(_closeRatio).div(1e4),\\n                    _positions[i].asset1.mul(_closeRatio).div(1e4)\\n                );\\n                index++;\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < _positions.length; i++) {\\n            if (_positions[i].debt0 > 0 || _positions[i].debt1 > 0) {\\n                positionUpdates[index] = DataType.PositionUpdate(\\n                    DataType.PositionUpdateType.REPAY_TOKEN,\\n                    _positions[i].subVaultIndex,\\n                    false,\\n                    0,\\n                    0,\\n                    0,\\n                    _positions[i].debt0.mul(_closeRatio).div(1e4),\\n                    _positions[i].debt1.mul(_closeRatio).div(1e4)\\n                );\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6af2b8dac883747758be9d0309d098a6e798e04794c225ae68233985277678e4\",\"license\":\"UNLICENSED\"},\"src/libraries/PredyMath.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.4.0 <0.8.0;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\n\\nlibrary PredyMath {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    /**\\n     * @dev https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\\n     */\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    /**\\n     * @dev https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\\n     */\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? b : a;\\n    }\\n\\n    function subReward(uint256 a, uint256 b) internal pure returns (uint256, uint256) {\\n        if (a >= b) {\\n            return (a - b, b);\\n        } else {\\n            return (0, a);\\n        }\\n    }\\n\\n    function addDelta(uint256 x, int256 y) internal pure returns (uint256 z) {\\n        if (y < 0) {\\n            require((z = x - uint256(-y)) < x, \\\"LS\\\");\\n        } else {\\n            require((z = x + uint256(y)) >= x, \\\"LA\\\");\\n        }\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x >= 0 ? x : -x);\\n    }\\n}\\n\",\"keccak256\":\"0xf4da1a162fb6e0902a6a483a899e7801f9cbc53695e58f06c7b523721d8e41e8\",\"license\":\"AGPL-3.0-only\"},\"src/libraries/VaultLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/SafeCast.sol\\\";\\nimport \\\"./PredyMath.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./LPTMath.sol\\\";\\nimport \\\"./BaseToken.sol\\\";\\nimport \\\"./DataType.sol\\\";\\nimport \\\"./PositionCalculator.sol\\\";\\nimport \\\"./PositionLib.sol\\\";\\n\\n/**\\n * Error Codes\\n * V0: no permission\\n */\\nlibrary VaultLib {\\n    using SafeMath for uint256;\\n    using SafeMath for uint128;\\n    using SignedSafeMath for int256;\\n    using SafeCast for uint256;\\n    using BaseToken for BaseToken.TokenState;\\n\\n    event SubVaultCreated(uint256 indexed vaultId, uint256 subVaultIndex, uint256 subVaultId);\\n    event SubVaultRemoved(uint256 indexed vaultId, uint256 subVaultIndex, uint256 subVaultId);\\n\\n    /**\\n     * @notice add sub-vault to the vault\\n     * @param _vault vault object\\n     * @param _subVaults sub-vaults map\\n     * @param _context context object\\n     * @param _subVaultIndex index of sub-vault in the vault to add\\n     */\\n    function addSubVault(\\n        DataType.Vault storage _vault,\\n        mapping(uint256 => DataType.SubVault) storage _subVaults,\\n        DataType.Context storage _context,\\n        uint256 _subVaultIndex\\n    ) internal returns (DataType.SubVault storage) {\\n        if (_subVaultIndex == _vault.subVaults.length) {\\n            uint256 subVaultId = _context.nextSubVaultId;\\n\\n            _context.nextSubVaultId += 1;\\n\\n            _vault.subVaults.push(subVaultId);\\n\\n            emit SubVaultCreated(_vault.vaultId, _subVaultIndex, subVaultId);\\n\\n            _subVaults[subVaultId].id = subVaultId;\\n\\n            return _subVaults[subVaultId];\\n        } else if (_subVaultIndex < _vault.subVaults.length) {\\n            uint256 subVaultId = _vault.subVaults[_subVaultIndex];\\n\\n            return _subVaults[subVaultId];\\n        } else {\\n            revert(\\\"V0\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice remove sub-vault from the vault\\n     * @param _vault vault object\\n     * @param _subVaultIndex index of sub-vault in the vault to remove\\n     */\\n    function removeSubVault(DataType.Vault storage _vault, uint256 _subVaultIndex) internal {\\n        uint256 subVaultId = _vault.subVaults[_subVaultIndex];\\n\\n        _vault.subVaults[_subVaultIndex] = _vault.subVaults[_vault.subVaults.length - 1];\\n        _vault.subVaults.pop();\\n\\n        emit SubVaultRemoved(_vault.vaultId, _subVaultIndex, subVaultId);\\n    }\\n\\n    function depositLPT(\\n        DataType.SubVault storage _subVault,\\n        DataType.PerpStatus memory _range,\\n        bytes32 _rangeId,\\n        uint128 _liquidityAmount\\n    ) internal {\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            DataType.LPTState storage lpt = _subVault.lpts[i];\\n\\n            if (lpt.rangeId == _rangeId && lpt.isCollateral) {\\n                lpt.premiumGrowthLast = updateEntryPrice(\\n                    lpt.premiumGrowthLast,\\n                    lpt.liquidityAmount,\\n                    _range.premiumGrowthForLender,\\n                    _liquidityAmount\\n                );\\n\\n                lpt.fee0Last = updateEntryPrice(lpt.fee0Last, lpt.liquidityAmount, _range.fee0Growth, _liquidityAmount);\\n                lpt.fee1Last = updateEntryPrice(lpt.fee1Last, lpt.liquidityAmount, _range.fee1Growth, _liquidityAmount);\\n\\n                lpt.liquidityAmount = lpt.liquidityAmount.add(_liquidityAmount).toUint128();\\n\\n                return;\\n            }\\n        }\\n\\n        _subVault.lpts.push(\\n            DataType.LPTState(\\n                true,\\n                _rangeId,\\n                _liquidityAmount,\\n                _range.premiumGrowthForLender,\\n                _range.fee0Growth,\\n                _range.fee1Growth\\n            )\\n        );\\n    }\\n\\n    function withdrawLPT(\\n        DataType.SubVault storage _subVault,\\n        DataType.PerpStatus memory _range,\\n        bytes32 _rangeId,\\n        uint128 _liquidityAmount,\\n        bool _isMarginZero\\n    )\\n        internal\\n        returns (\\n            uint256 fee0,\\n            uint256 fee1,\\n            uint128 liquidityAmount\\n        )\\n    {\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            DataType.LPTState storage lpt = _subVault.lpts[i];\\n\\n            if (lpt.rangeId == _rangeId && lpt.isCollateral) {\\n                liquidityAmount = _liquidityAmount;\\n\\n                if (_liquidityAmount > lpt.liquidityAmount) {\\n                    liquidityAmount = lpt.liquidityAmount;\\n                }\\n\\n                fee0 = calculateProfit(lpt.fee0Last, _range.fee0Growth, liquidityAmount, Constants.ONE);\\n\\n                fee1 = calculateProfit(lpt.fee1Last, _range.fee1Growth, liquidityAmount, Constants.ONE);\\n\\n                {\\n                    uint256 profit = calculateProfit(\\n                        lpt.premiumGrowthLast,\\n                        _range.premiumGrowthForLender,\\n                        liquidityAmount,\\n                        Constants.ONE\\n                    );\\n\\n                    if (_isMarginZero) {\\n                        fee0 += profit;\\n                    } else {\\n                        fee1 += profit;\\n                    }\\n                }\\n\\n                lpt.liquidityAmount = lpt.liquidityAmount.sub(liquidityAmount).toUint128();\\n\\n                if (lpt.liquidityAmount == 0) {\\n                    _subVault.lpts[i] = _subVault.lpts[_subVault.lpts.length - 1];\\n                    _subVault.lpts.pop();\\n                }\\n\\n                return (fee0, fee1, liquidityAmount);\\n            }\\n        }\\n    }\\n\\n    function borrowLPT(\\n        DataType.SubVault storage _subVault,\\n        DataType.PerpStatus memory _range,\\n        bytes32 _rangeId,\\n        uint128 _liquidityAmount\\n    ) internal {\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            DataType.LPTState storage lpt = _subVault.lpts[i];\\n\\n            if (lpt.rangeId == _rangeId && !lpt.isCollateral) {\\n                lpt.premiumGrowthLast = updateEntryPrice(\\n                    lpt.premiumGrowthLast,\\n                    lpt.liquidityAmount,\\n                    _range.premiumGrowthForBorrower,\\n                    _liquidityAmount\\n                );\\n\\n                lpt.liquidityAmount = lpt.liquidityAmount.add(_liquidityAmount).toUint128();\\n\\n                return;\\n            }\\n        }\\n\\n        _subVault.lpts.push(\\n            DataType.LPTState(false, _rangeId, _liquidityAmount, _range.premiumGrowthForBorrower, 0, 0)\\n        );\\n    }\\n\\n    function repayLPT(\\n        DataType.SubVault storage _subVault,\\n        DataType.PerpStatus memory _range,\\n        bytes32 _rangeId,\\n        uint128 _liquidityAmount,\\n        bool _isMarginZero\\n    )\\n        internal\\n        returns (\\n            uint256 fee0,\\n            uint256 fee1,\\n            uint128 liquidityAmount\\n        )\\n    {\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            DataType.LPTState storage lpt = _subVault.lpts[i];\\n\\n            if (lpt.rangeId == _rangeId && !lpt.isCollateral) {\\n                liquidityAmount = _liquidityAmount;\\n\\n                if (_liquidityAmount > lpt.liquidityAmount) {\\n                    liquidityAmount = lpt.liquidityAmount;\\n                }\\n\\n                {\\n                    uint256 profit = calculateProfit(\\n                        lpt.premiumGrowthLast,\\n                        _range.premiumGrowthForBorrower,\\n                        liquidityAmount,\\n                        Constants.ONE\\n                    );\\n\\n                    if (_isMarginZero) {\\n                        fee0 += profit;\\n                    } else {\\n                        fee1 += profit;\\n                    }\\n                }\\n\\n                lpt.liquidityAmount = lpt.liquidityAmount.sub(liquidityAmount).toUint128();\\n\\n                if (lpt.liquidityAmount == 0) {\\n                    _subVault.lpts[i] = _subVault.lpts[_subVault.lpts.length - 1];\\n                    _subVault.lpts.pop();\\n                }\\n\\n                return (fee0, fee1, liquidityAmount);\\n            }\\n        }\\n    }\\n\\n    function updateEntryPrice(\\n        uint256 _entryPrice,\\n        uint256 _position,\\n        uint256 _tradePrice,\\n        uint256 _positionTrade\\n    ) internal pure returns (uint256 newEntryPrice) {\\n        newEntryPrice = (_entryPrice.mul(_position).add(_tradePrice.mul(_positionTrade))).div(\\n            _position.add(_positionTrade)\\n        );\\n    }\\n\\n    function calculateProfit(\\n        uint256 _entryPrice,\\n        uint256 _tradePrice,\\n        uint256 _positionTrade,\\n        uint256 _denominator\\n    ) internal pure returns (uint256 profit) {\\n        return _tradePrice.sub(_entryPrice).mul(_positionTrade).div(_denominator);\\n    }\\n\\n    function getVaultStatus(\\n        DataType.Vault memory _vault,\\n        mapping(uint256 => DataType.SubVault) storage _subVaults,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context,\\n        uint160 _sqrtPrice\\n    ) external view returns (DataType.VaultStatus memory) {\\n        DataType.SubVaultStatus[] memory subVaultsStatus = new DataType.SubVaultStatus[](_vault.subVaults.length);\\n\\n        for (uint256 i = 0; i < _vault.subVaults.length; i++) {\\n            DataType.SubVaultAmount memory statusAmount = getVaultStatusAmount(\\n                _subVaults[_vault.subVaults[i]],\\n                _ranges,\\n                _context,\\n                _sqrtPrice\\n            );\\n\\n            DataType.SubVaultPremium memory subVaultPremium = getVaultStatusPremium(\\n                _subVaults[_vault.subVaults[i]],\\n                _ranges\\n            );\\n\\n            DataType.SubVaultInterest memory statusInterest = getVaultStatusInterest(\\n                _subVaults[_vault.subVaults[i]],\\n                _context\\n            );\\n\\n            subVaultsStatus[i] = DataType.SubVaultStatus(\\n                getVaultStatusValue(statusAmount, statusInterest, subVaultPremium, _sqrtPrice, _context.isMarginZero),\\n                statusAmount,\\n                statusInterest,\\n                subVaultPremium\\n            );\\n        }\\n\\n        PositionCalculator.PositionCalculatorParams memory params = getPositionCalculatorParams(\\n            _vault,\\n            _subVaults,\\n            _ranges,\\n            _context\\n        );\\n\\n        (int256 marginValue, uint256 assetValue, uint256 debtValue) = PositionCalculator\\n            .calculateCollateralAndDebtValue(params, _sqrtPrice, _context.isMarginZero, false);\\n\\n        return\\n            DataType.VaultStatus(\\n                int256(assetValue) - int256(debtValue),\\n                marginValue,\\n                PositionCalculator.calculateMinDeposit(params, _sqrtPrice, _context.isMarginZero),\\n                subVaultsStatus\\n            );\\n    }\\n\\n    function getMarginAmount(\\n        DataType.Vault memory _vault,\\n        mapping(uint256 => DataType.SubVault) storage _subVaults,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context\\n    ) internal view returns (int256 marginAmount0, int256 marginAmount1) {\\n        (int256 fee0, int256 fee1) = getPremiumAndFee(_vault, _subVaults, _ranges, _context);\\n\\n        marginAmount0 = int256(_vault.marginAmount0) + fee0;\\n        marginAmount1 = int256(_vault.marginAmount1) + fee1;\\n    }\\n\\n    function getVaultValue(\\n        DataType.Context memory _context,\\n        PositionCalculator.PositionCalculatorParams memory _params,\\n        uint160 _sqrtPrice\\n    ) internal pure returns (int256) {\\n        return PositionCalculator.calculateValue(_params, _sqrtPrice, _context.isMarginZero, false);\\n    }\\n\\n    function getVaultStatusValue(\\n        DataType.SubVaultAmount memory statusAmount,\\n        DataType.SubVaultInterest memory statusInterest,\\n        DataType.SubVaultPremium memory statusPremium,\\n        uint160 _sqrtPrice,\\n        bool _isMarginZero\\n    ) internal pure returns (DataType.SubVaultValue memory) {\\n        uint256 price = LPTMath.decodeSqrtPriceX96(_isMarginZero, _sqrtPrice);\\n\\n        int256 fee0 = statusInterest.assetFee0 - statusInterest.debtFee0;\\n        int256 fee1 = statusInterest.assetFee1 - statusInterest.debtFee1;\\n\\n        fee0 += int256(statusPremium.receivedTradeAmount0);\\n        fee1 += int256(statusPremium.receivedTradeAmount1);\\n\\n        int256 premium = int256(statusPremium.receivedPremium).sub(int256(statusPremium.paidPremium));\\n\\n        if (_isMarginZero) {\\n            return\\n                DataType.SubVaultValue(\\n                    PredyMath.mulDiv(statusAmount.assetAmount1, price, 1e18).add(statusAmount.assetAmount0),\\n                    PredyMath.mulDiv(statusAmount.debtAmount1, price, 1e18).add(statusAmount.debtAmount0),\\n                    (fee1.mul(int256(price)).div(1e18).add(fee0)).add(premium)\\n                );\\n        } else {\\n            return\\n                DataType.SubVaultValue(\\n                    PredyMath.mulDiv(statusAmount.assetAmount0, price, 1e18).add(statusAmount.assetAmount1),\\n                    PredyMath.mulDiv(statusAmount.debtAmount0, price, 1e18).add(statusAmount.debtAmount1),\\n                    (fee0.mul(int256(price)).div(1e18).add(fee1)).add(premium)\\n                );\\n        }\\n    }\\n\\n    function getVaultStatusAmount(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context,\\n        uint160 _sqrtPrice\\n    ) internal view returns (DataType.SubVaultAmount memory) {\\n        (uint256 assetAmount0, uint256 assetAmount1) = getAssetPositionAmounts(\\n            _subVault,\\n            _ranges,\\n            _context,\\n            _sqrtPrice\\n        );\\n        (uint256 debtAmount0, uint256 debtAmount1) = getDebtPositionAmounts(_subVault, _ranges, _context, _sqrtPrice);\\n\\n        return DataType.SubVaultAmount(assetAmount0, assetAmount1, debtAmount0, debtAmount1);\\n    }\\n\\n    function getVaultStatusPremium(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges\\n    ) internal view returns (DataType.SubVaultPremium memory) {\\n        (uint256 fee0, uint256 fee1) = getEarnedTradeFee(_subVault, _ranges);\\n\\n        return\\n            DataType.SubVaultPremium(\\n                fee0,\\n                fee1,\\n                getEarnedDailyPremium(_subVault, _ranges),\\n                getPaidDailyPremium(_subVault, _ranges)\\n            );\\n    }\\n\\n    function getVaultStatusInterest(DataType.SubVault memory _subVault, DataType.Context memory _context)\\n        internal\\n        pure\\n        returns (DataType.SubVaultInterest memory)\\n    {\\n        (int256 assetFee0, int256 assetFee1, int256 debtFee0, int256 debtFee1) = getTokenInterestOfSubVault(\\n            _subVault,\\n            _context\\n        );\\n\\n        return DataType.SubVaultInterest(assetFee0, assetFee1, debtFee0, debtFee1);\\n    }\\n\\n    function isDebtZero(\\n        DataType.Vault memory _vault,\\n        mapping(uint256 => DataType.SubVault) storage _subVaults,\\n        DataType.Context memory _context\\n    ) external view returns (bool) {\\n        for (uint256 i = 0; i < _vault.subVaults.length; i++) {\\n            if (!isDebtZeroInSubVault(_subVaults[_vault.subVaults[i]], _context)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function isDebtZeroInSubVault(DataType.SubVault memory _subVault, DataType.Context memory _context)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (\\n            _context.tokenState0.getDebtValue(_subVault.balance0) != 0 ||\\n            _context.tokenState1.getDebtValue(_subVault.balance1) != 0\\n        ) {\\n            return false;\\n        }\\n\\n        if (_subVault.lpts.length > 0) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice latest asset amounts\\n     */\\n    function getAssetPositionAmounts(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context,\\n        uint160 _sqrtPrice\\n    ) internal view returns (uint256 totalAmount0, uint256 totalAmount1) {\\n        totalAmount0 = totalAmount0.add(_context.tokenState0.getAssetValue(_subVault.balance0));\\n        totalAmount1 = totalAmount1.add(_context.tokenState1.getAssetValue(_subVault.balance1));\\n\\n        {\\n            (uint256 amount0, uint256 amount1) = getLPTPositionAmounts(_subVault, _ranges, _sqrtPrice, true);\\n\\n            totalAmount0 = totalAmount0.add(amount0);\\n            totalAmount1 = totalAmount1.add(amount1);\\n        }\\n    }\\n\\n    function getDebtPositionAmounts(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context,\\n        uint160 _sqrtPrice\\n    ) internal view returns (uint256 totalAmount0, uint256 totalAmount1) {\\n        totalAmount0 = totalAmount0.add(_context.tokenState0.getDebtValue(_subVault.balance0));\\n        totalAmount1 = totalAmount1.add(_context.tokenState1.getDebtValue(_subVault.balance1));\\n\\n        {\\n            (uint256 amount0, uint256 amount1) = getLPTPositionAmounts(_subVault, _ranges, _sqrtPrice, false);\\n\\n            totalAmount0 = totalAmount0.add(amount0);\\n            totalAmount1 = totalAmount1.add(amount1);\\n        }\\n    }\\n\\n    function getLPTPositionAmounts(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        uint160 _sqrtPrice,\\n        bool _isCollateral\\n    ) internal view returns (uint256 totalAmount0, uint256 totalAmount1) {\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            if (_isCollateral != _subVault.lpts[i].isCollateral) {\\n                continue;\\n            }\\n\\n            (uint256 amount0, uint256 amount1) = LPTMath.getAmountsForLiquidity(\\n                _sqrtPrice,\\n                _ranges[_subVault.lpts[i].rangeId].lowerTick,\\n                _ranges[_subVault.lpts[i].rangeId].upperTick,\\n                _subVault.lpts[i].liquidityAmount\\n            );\\n\\n            totalAmount0 = totalAmount0.add(amount0);\\n            totalAmount1 = totalAmount1.add(amount1);\\n        }\\n    }\\n\\n    function getEarnedTradeFeeForRange(DataType.LPTState memory _lpt, DataType.PerpStatus memory _range)\\n        internal\\n        pure\\n        returns (uint256 totalAmount0, uint256 totalAmount1)\\n    {\\n        if (_lpt.isCollateral) {\\n            totalAmount0 = (\\n                PredyMath.mulDiv(_range.fee0Growth.sub(_lpt.fee0Last), _lpt.liquidityAmount, Constants.ONE)\\n            );\\n            totalAmount1 = (\\n                PredyMath.mulDiv(_range.fee1Growth.sub(_lpt.fee1Last), _lpt.liquidityAmount, Constants.ONE)\\n            );\\n        }\\n    }\\n\\n    function getEarnedTradeFee(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage ranges\\n    ) public view returns (uint256 totalAmount0, uint256 totalAmount1) {\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            bytes32 rangeId = _subVault.lpts[i].rangeId;\\n\\n            (uint256 amount0, uint256 amount1) = getEarnedTradeFeeForRange(_subVault.lpts[i], ranges[rangeId]);\\n\\n            totalAmount0 = totalAmount0.add(amount0);\\n            totalAmount1 = totalAmount1.add(amount1);\\n        }\\n    }\\n\\n    function getEarnedDailyPremium(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage ranges\\n    ) public view returns (uint256 marginValue) {\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            bytes32 rangeId = _subVault.lpts[i].rangeId;\\n            DataType.PerpStatus memory perpStatus = ranges[rangeId];\\n\\n            if (_subVault.lpts[i].isCollateral) {\\n                marginValue = marginValue.add(\\n                    PredyMath.mulDiv(\\n                        (perpStatus.premiumGrowthForLender.sub(_subVault.lpts[i].premiumGrowthLast)),\\n                        _subVault.lpts[i].liquidityAmount,\\n                        Constants.ONE\\n                    )\\n                );\\n            }\\n        }\\n    }\\n\\n    function getPaidDailyPremium(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage ranges\\n    ) public view returns (uint256 marginValue) {\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            bytes32 rangeId = _subVault.lpts[i].rangeId;\\n            DataType.PerpStatus memory perpStatus = ranges[rangeId];\\n\\n            if (!_subVault.lpts[i].isCollateral) {\\n                marginValue = marginValue.add(\\n                    PredyMath.mulDiv(\\n                        (perpStatus.premiumGrowthForBorrower.sub(_subVault.lpts[i].premiumGrowthLast)),\\n                        _subVault.lpts[i].liquidityAmount,\\n                        Constants.ONE\\n                    )\\n                );\\n            }\\n        }\\n    }\\n\\n    function getPremiumAndFee(\\n        DataType.Vault memory _vault,\\n        mapping(uint256 => DataType.SubVault) storage _subVaults,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context\\n    ) internal view returns (int256 totalFee0, int256 totalFee1) {\\n        for (uint256 i = 0; i < _vault.subVaults.length; i++) {\\n            DataType.SubVault memory subVault = _subVaults[_vault.subVaults[i]];\\n\\n            (int256 fee0, int256 fee1) = getPremiumAndFeeOfSubVault(subVault, _ranges, _context);\\n            (int256 assetFee0, int256 assetFee1, int256 debtFee0, int256 debtFee1) = getTokenInterestOfSubVault(\\n                subVault,\\n                _context\\n            );\\n\\n            totalFee0 = totalFee0.add(fee0.add(assetFee0).sub(debtFee0));\\n            totalFee1 = totalFee1.add(fee1.add(assetFee1).sub(debtFee1));\\n        }\\n    }\\n\\n    function getPremiumAndFeeOfSubVault(\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context\\n    ) internal view returns (int256 totalFee0, int256 totalFee1) {\\n        (uint256 fee0, uint256 fee1) = getEarnedTradeFee(_subVault, _ranges);\\n\\n        totalFee0 = totalFee0.add(int256(fee0));\\n        totalFee1 = totalFee1.add(int256(fee1));\\n\\n        if (_context.isMarginZero) {\\n            totalFee0 = totalFee0.add(int256(getEarnedDailyPremium(_subVault, _ranges)));\\n            totalFee0 = totalFee0.sub(int256(getPaidDailyPremium(_subVault, _ranges)));\\n        } else {\\n            totalFee1 = totalFee1.add(int256(getEarnedDailyPremium(_subVault, _ranges)));\\n            totalFee1 = totalFee1.sub(int256(getPaidDailyPremium(_subVault, _ranges)));\\n        }\\n    }\\n\\n    function getTokenInterestOfSubVault(DataType.SubVault memory _subVault, DataType.Context memory _context)\\n        internal\\n        pure\\n        returns (\\n            int256 assetFee0,\\n            int256 assetFee1,\\n            int256 debtFee0,\\n            int256 debtFee1\\n        )\\n    {\\n        assetFee0 = int256(_context.tokenState0.getAssetFee(_subVault.balance0));\\n        assetFee1 = int256(_context.tokenState1.getAssetFee(_subVault.balance1));\\n        debtFee0 = int256(_context.tokenState0.getDebtFee(_subVault.balance0));\\n        debtFee1 = int256(_context.tokenState1.getDebtFee(_subVault.balance1));\\n    }\\n\\n    function getPositionOfSubVault(\\n        uint256 _subVaultIndex,\\n        DataType.SubVault memory _subVault,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context\\n    ) internal view returns (DataType.Position memory position) {\\n        DataType.LPT[] memory lpts = new DataType.LPT[](_subVault.lpts.length);\\n\\n        for (uint256 i = 0; i < _subVault.lpts.length; i++) {\\n            bytes32 rangeId = _subVault.lpts[i].rangeId;\\n            DataType.PerpStatus memory range = _ranges[rangeId];\\n            lpts[i] = DataType.LPT(\\n                _subVault.lpts[i].isCollateral,\\n                _subVault.lpts[i].liquidityAmount,\\n                range.lowerTick,\\n                range.upperTick\\n            );\\n        }\\n\\n        position = DataType.Position(\\n            _subVaultIndex,\\n            _context.tokenState0.getAssetValue(_subVault.balance0),\\n            _context.tokenState1.getAssetValue(_subVault.balance1),\\n            _context.tokenState0.getDebtValue(_subVault.balance0),\\n            _context.tokenState1.getDebtValue(_subVault.balance1),\\n            lpts\\n        );\\n    }\\n\\n    function getPositions(\\n        DataType.Vault memory _vault,\\n        mapping(uint256 => DataType.SubVault) storage _subVaults,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context\\n    ) internal view returns (DataType.Position[] memory positions) {\\n        positions = new DataType.Position[](_vault.subVaults.length);\\n\\n        for (uint256 i = 0; i < _vault.subVaults.length; i++) {\\n            positions[i] = getPositionOfSubVault(i, _subVaults[_vault.subVaults[i]], _ranges, _context);\\n        }\\n    }\\n\\n    function getPosition(\\n        DataType.Vault memory _vault,\\n        mapping(uint256 => DataType.SubVault) storage _subVaults,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context\\n    ) internal view returns (DataType.Position memory position) {\\n        return PositionLib.concat(VaultLib.getPositions(_vault, _subVaults, _ranges, _context));\\n    }\\n\\n    function getPositionCalculatorParams(\\n        DataType.Vault memory _vault,\\n        mapping(uint256 => DataType.SubVault) storage _subVaults,\\n        mapping(bytes32 => DataType.PerpStatus) storage _ranges,\\n        DataType.Context memory _context\\n    ) public view returns (PositionCalculator.PositionCalculatorParams memory params) {\\n        {\\n            DataType.Position memory position = getPosition(_vault, _subVaults, _ranges, _context);\\n            params.asset0 = position.asset0;\\n            params.asset1 = position.asset1;\\n            params.debt0 = position.debt0;\\n            params.debt1 = position.debt1;\\n            params.lpts = position.lpts;\\n        }\\n\\n        (params.marginAmount0, params.marginAmount1) = getMarginAmount(_vault, _subVaults, _ranges, _context);\\n    }\\n}\\n\",\"keccak256\":\"0x9ee0e3e6cd6d894938f252688d8c947c91618cd379406cba0e743f724d7dc079\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x613838610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061006c5760003560e01c8063213f76c41461007157806322b4a7841461009a57806329399f42146100ad5780634a3cb0c7146100cd57806375c3f240146100ed578063bb1a8b061461010e575b600080fd5b61008461007f366004613328565b61012e565b60405161009191906136e5565b60405180910390f35b6100846100a8366004613328565b61028e565b6100c06100bb3660046133d8565b6103ac565b6040516100919190613547565b6100e06100db3660046134a3565b610417565b604051610091919061351f565b6101006100fb366004613328565b610607565b6040516100919291906136ee565b61012161011c36600461342d565b610717565b604051610091919061360e565b6000805b8360600151518110156102875760008460600151828151811061015157fe5b60209081029190910181015181015160008181528683526040908190208151610100810183528154600281810b810b810b835263010000008204810b810b810b96830196909652600160301b90046001600160801b0316928101929092526001810154606080840191909152938101546080830152600381015460a0830152600481015460c08301526005015460e082015291870151805191935090849081106101f757fe5b6020026020010151600001511561027d5761027a6102736102408860600151868151811061022157fe5b6020026020010151606001518460800151610d8d90919063ffffffff16565b8860600151868151811061025057fe5b6020026020010151604001516001600160801b0316670de0b6b3a7640000610def565b8590610e0e565b93505b5050600101610132565b5092915050565b6000805b836060015151811015610287576000846060015182815181106102b157fe5b60209081029190910181015181015160008181528683526040908190208151610100810183528154600281810b810b810b835263010000008204810b810b810b96830196909652600160301b90046001600160801b0316928101929092526001810154606080840191909152938101546080830152600381015460a0830152600481015460c08301526005015460e0820152918701518051919350908490811061035757fe5b6020026020010151600001516103a25761039f6102736102408860600151868151811061038057fe5b6020026020010151606001518460600151610d8d90919063ffffffff16565b93505b5050600101610292565b6103b4612e1e565b60006103c286868686610e68565b602081015160408085019190915281015160608085019190915281015160808085019190915281015160a080850191909152015160c08301525061040885858585610e84565b60208301528152949350505050565b6000805b8460600151518110156105fa576105e48460008760600151848151811061043e57fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff16600281111561049757fe5b60028111156104a257fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff16600281111561050057fe5b600281111561050b57fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b828210156105d65760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a08301529083529092019101610560565b505050508152505084610eb3565b6105f2576000915050610600565b60010161041b565b50600190505b9392505050565b60008060005b84606001515181101561070f5760008560600151828151811061062c57fe5b60200260200101516020015190506000806106e38860600151858151811061065057fe5b60209081029190910181015160008681528a83526040908190208151610100810183528154600281810b810b810b835263010000008204810b810b810b96830196909652600160301b90046001600160801b03169281019290925260018101546060830152928301546080820152600383015460a0820152600483015460c082015260059092015460e083015290610f18565b90925090506106f28683610e0e565b95506106fe8582610e0e565b9450506001909201915061060d9050565b509250929050565b61071f612e5b565b60008660600151516001600160401b038111801561073c57600080fd5b5060405190808252806020026020018201604052801561077657816020015b610763612e83565b81526020019060019003908161075b5790505b50905060005b876060015151811015610d1e5760006109498860008b6060015185815181106107a157fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff1660028111156107fa57fe5b600281111561080557fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff16600281111561086357fe5b600281111561086e57fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b828210156109395760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a083015290835290920191016108c3565b5050505081525050888888610f89565b90506000610b098960008c60600151868151811061096357fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff1660028111156109bc57fe5b60028111156109c757fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff166002811115610a2557fe5b6002811115610a3057fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b82821015610afb5760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a08301529083529092019101610a85565b505050508152505089610fdc565b90506000610cc98a60008d606001518781518110610b2357fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff166002811115610b7c57fe5b6002811115610b8757fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff166002811115610be557fe5b6002811115610bf057fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b82821015610cbb5760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a08301529083529092019101610c45565b505050508152505089611030565b90506040518060800160405280610ce78584868c8e60a00151611071565b815260200184815260200182815260200183815250858581518110610d0857fe5b602090810291909101015250505060010161077c565b506000610d2d888888886103ac565b90506000806000610d4584888a60a0015160006111e3565b92509250925060405180608001604052808284038152602001848152602001610d73868a8c60a00151611316565b815260200186815250955050505050505b95945050505050565b600082821115610de4576040805162461bcd60e51b815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b508082035b92915050565b828202811515841585830485141716610e0757600080fd5b0492915050565b600082820183811015610600576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b610e70612ec2565b610d84610e7f8686868661139a565b6115ea565b600080600080610e96888888886117e7565b60208a01516040909a015199909101999801979650505050505050565b6000610ed083602001518360e00151611a2e90919063ffffffff16565b151580610eef57506040830151610100830151610eec91611a2e565b15155b15610efc57506000610de9565b60608301515115610f0f57506000610de9565b50600192915050565b600080836000015115610f8257610f5f610f4385608001518560a00151610d8d90919063ffffffff16565b85604001516001600160801b0316670de0b6b3a7640000610def565b9150610f7f610f438560a001518560c00151610d8d90919063ffffffff16565b90505b9250929050565b610f91612ef8565b600080610fa087878787611a72565b91509150600080610fb389898989611af5565b604080516080810182529687526020870195909552938501525050606082015295945050505050565b610fe4612ef8565b600080610ff18585610607565b915091506040518060800160405280838152602001828152602001611016878761012e565b8152602001611025878761028e565b905295945050505050565b611038612ef8565b6000806000806110488787611b49565b604080516080810182529485526020850193909352918301526060820152979650505050505050565b611079612f20565b600061108e83856001600160a01b0316611bce565b905060008660400151876000015103905060008760600151886020015103905086600001518201915086602001518101905060006110dd88606001518960400151611c9490919063ffffffff16565b905085156111745760405180606001604052806111158c6000015161110f8e6020015189670de0b6b3a7640000610def565b90610e0e565b81526020016111398c6040015161110f8e6060015189670de0b6b3a7640000610def565b8152602001611166836111608781670de0b6b3a764000061115a8a8d611cf9565b90611da2565b90611e5a565b815250945050505050610d84565b604051806060016040528061119e8c6020015161110f8e6000015189670de0b6b3a7640000610def565b81526020016111c28c6060015161110f8e6040015189670de0b6b3a7640000610def565b8152602001611166836111608681670de0b6b3a764000061115a8b8d611cf9565b6000806000806111fc86886001600160a01b0316611bce565b905085156112395761123261122a670de0b6b3a764000061115a848c60200151611cf990919063ffffffff16565b895190611e5a565b9350611267565b6112648860200151611160670de0b6b3a764000061115a858d60000151611cf990919063ffffffff16565b93505b6000806000806112788c8c8b611ebf565b935093509350935089156112ce576112a5610273670de0b6b3a764000061129f8689612033565b9061208c565b96506112c76112c0670de0b6b3a764000061129f8489612033565b8390610e0e565b9550611307565b6112e88361110f670de0b6b3a764000061129f888a612033565b96506113048161110f670de0b6b3a764000061129f868a612033565b95505b50505050509450945094915050565b6000806113248585856120f3565b9050600061133386868661210a565b9050600061134487878760006111e3565b925050506113708261136a85611160620f424061129f87611364896122d2565b90612033565b90611c94565b9350620f4240841280156113845750600081115b1561139057620f424093505b5050509392505050565b60608460600151516001600160401b03811180156113b757600080fd5b506040519080825280602002602001820160405280156113f157816020015b6113de612ec2565b8152602001906001900390816113d65790505b50905060005b8560600151518110156115e1576115c2818660008960600151858151811061141b57fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff16600281111561147457fe5b600281111561147f57fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff1660028111156114dd57fe5b60028111156114e857fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b828210156115b35760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a0830152908352909201910161153d565b50505050815250508686612307565b8282815181106115ce57fe5b60209081029190910101526001016113f7565b50949350505050565b6115f2612ec2565b6000805b83518110156116295783818151811061160b57fe5b602002602001015160a00151518201915080806001019150506115f6565b506000816001600160401b038111801561164257600080fd5b5060405190808252806020026020018201604052801561167c57816020015b611669612f41565b8152602001906001900390816116615790505b5090506040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001828152509250600080600090505b85518110156117de578581815181106116d057fe5b6020026020010151602001518560200181815101915081815250508581815181106116f757fe5b60200260200101516040015185604001818151019150818152505085818151811061171e57fe5b60200260200101516060015185606001818151019150818152505085818151811061174557fe5b60200260200101516080015185608001818151019150818152505060005b86828151811061176f57fe5b602002602001015160a00151518110156117d55786828151811061178f57fe5b602002602001015160a0015181815181106117a657fe5b60200260200101518660a0015184815181106117be57fe5b602090810291909101015260019283019201611763565b506001016116bb565b50505050919050565b60008060005b866060015151811015611a245760008660008960600151848151811061180f57fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff16600281111561186857fe5b600281111561187357fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff1660028111156118d157fe5b60028111156118dc57fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b828210156119a75760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a08301529083529092019101611931565b505050508152505090506000806119bf838989612558565b915091506000806000806119d3878c611b49565b929650909450925090506119f56119ee8361136a8988611e5a565b8b90611e5a565b9950611a0f611a088261136a8887611e5a565b8a90611e5a565b985050600190960195506117ed945050505050565b5094509492505050565b6000600182516002811115611a3f57fe5b1415611a6757611a6082604001518460a00151670de0b6b3a7640000610def565b9050610de9565b506040810151610de9565b600080611a936112c087602001518660e001516125f790919063ffffffff16565b9150611abb611ab487604001518661010001516125f790919063ffffffff16565b8290610e0e565b9050600080611acd8888876001612634565b9092509050611adc8483610e0e565b9350611ae88382610e0e565b9250505094509492505050565b600080611b166112c087602001518660e00151611a2e90919063ffffffff16565b9150611b37611ab48760400151866101000151611a2e90919063ffffffff16565b9050600080611acd8888876000612634565b600080600080611b6a86602001518660e0015161273e90919063ffffffff16565b9350611b88866040015186610100015161273e90919063ffffffff16565b9250611ba586602001518660e0015161278d90919063ffffffff16565b9150611bc3866040015186610100015161278d90919063ffffffff16565b905092959194509250565b6000670de0b6b3a76400008315611c3657611bf7838483600160c01b81611bf157fe5b046127dc565b915081611c16576ec097ce7bc90715b34b9f1000000000915050610de9565b816ec097ce7bc90715b34b9f100000000081611c2e57fe5b049150611c57565b600160601b81611c4b8586600160601b6127dc565b0281611c5357fe5b0491505b6ec097ce7bc90715b34b9f1000000000821115611c85576ec097ce7bc90715b34b9f10000000009150610287565b81610287575060019392505050565b6000818303818312801590611ca95750838113155b80611cbe5750600083128015611cbe57508381135b6106005760405162461bcd60e51b81526004018080602001828103825260248152602001806137df6024913960400191505060405180910390fd5b600082611d0857506000610de9565b82600019148015611d1c5750600160ff1b82145b15611d585760405162461bcd60e51b81526004018080602001828103825260278152602001806137b86027913960400191505060405180910390fd5b82820282848281611d6557fe5b05146106005760405162461bcd60e51b81526004018080602001828103825260278152602001806137b86027913960400191505060405180910390fd5b600081611df6576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b81600019148015611e0a5750600160ff1b83145b15611e465760405162461bcd60e51b81526004018080602001828103825260218152602001806137766021913960400191505060405180910390fd5b6000828481611e5157fe5b05949350505050565b6000828201818312801590611e6f5750838112155b80611e845750600083128015611e8457508381125b6106005760405162461bcd60e51b81526004018080602001828103825260218152602001806137556021913960400191505060405180910390fd5b60408301516060840151608085015160a086015160005b8760c00151518110156120295760008860c001518281518110611ef557fe5b602002602001015190506000611f0e826040015161288b565b90506000611f1f836060015161288b565b9050888015611f2d57508251155b8015611f4b5750896001600160a01b0316826001600160a01b031611155b8015611f695750806001600160a01b03168a6001600160a01b031611155b15611fc657611fbc611fb5600160601b61129f611f89876040015161288b565b611f96886060015161288b565b60208901516001600160801b0316916001600160a01b03910316612033565b8690610e0e565b9450505050612021565b600080611fd98c85858860200151612bbd565b865191935091501561200257611fef8a83610e0e565b9950611ffb8982610e0e565b985061201b565b61200c8883610e0e565b97506120188782610e0e565b96505b50505050505b600101611ed6565b5093509350935093565b60008261204257506000610de9565b8282028284828161204f57fe5b04146106005760405162461bcd60e51b81526004018080602001828103825260218152602001806137976021913960400191505060405180910390fd5b60008082116120e2576040805162461bcd60e51b815260206004820152601a60248201527f536166654d6174683a206469766973696f6e206279207a65726f000000000000604482015290519081900360640190fd5b8183816120eb57fe5b049392505050565b60006121028484846000612c59565b949350505050565b6001600160ff1b036305f5e1006001600160a01b0363057caf768502811682900491630679875d86028216049085166401000276a3108015612168575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038616105b61218d5760405162461bcd60e51b81526004016121849061352a565b60405180910390fd5b6401000276a36001600160a01b03831610156121ac576401000276a391505b73fffd8963efd1fc6a506488495d951d5263988d266001600160a01b03821611156121e8575073fffd8963efd1fc6a506488495d951d5263988d265b60006121f58783876120f3565b905080841315612203578093505b5060006122118784876120f3565b90508084131561221f578093505b5060005b8660c00151518110156113905760008760c00151828151811061224257fe5b6020026020010151905080600001516122c857600061226982606001518360400151612c7a565b9050846001600160a01b0316816001600160a01b0316108061229c5750806001600160a01b0316846001600160a01b0316105b156122a85750506122ca565b60006122b78a838a6001612c59565b9050808713156122c5578096505b50505b505b600101612223565b60006122ff6122f7620f424061129f6122ef86620f424002612c8c565b603290612033565b614e20612d30565b90505b919050565b61230f612ec2565b60008460600151516001600160401b038111801561232c57600080fd5b5060405190808252806020026020018201604052801561236657816020015b612353612f41565b81526020019060019003908161234b5790505b50905060005b8560600151518110156124b75760008660600151828151811061238b57fe5b60209081029190910181015181015160008181528883526040908190208151610100810183528154600281810b810b810b835263010000008204810b810b810b96830196909652600160301b90046001600160801b031681840152600182015460608083019190915294820154608080830191909152600383015460a0830152600483015460c083015260059092015460e08201528251918201909252928a015180519294509092918291908690811061244157fe5b602002602001015160000151151581526020018960600151858151811061246457fe5b6020026020010151604001516001600160801b03168152602001826000015160020b8152602001826020015160020b8152508484815181106124a257fe5b6020908102919091010152505060010161236c565b506040518060c001604052808781526020016124e487602001518660e001516125f790919063ffffffff16565b815260200161250587604001518661010001516125f790919063ffffffff16565b815260200161252587602001518660e00151611a2e90919063ffffffff16565b81526020016125468760400151866101000151611a2e90919063ffffffff16565b81526020019190915295945050505050565b6000806000806125688787610607565b90925090506125778483611e5a565b93506125838382611e5a565b92508460a00151156125c0576125a361259c888861012e565b8590611e5a565b93506125b96125b2888861028e565b8590611c94565b93506125ed565b6125d46125cd888861012e565b8490611e5a565b92506125ea6125e3888861028e565b8490611c94565b92505b5050935093915050565b600060018251600281111561260857fe5b141561262957611a6082602001518460800151670de0b6b3a7640000610def565b506020810151610de9565b60008060005b866060015151811015611a24578660600151818151811061265757fe5b60200260200101516000015115158415151461267257612736565b600080612716878960008c60600151878151811061268c57fe5b602002602001015160200151815260200190815260200160002060000160009054906101000a900460020b8a60008d6060015188815181106126ca57fe5b602002602001015160200151815260200190815260200160002060000160039054906101000a900460020b8c60600151878151811061270557fe5b602002602001015160400151612d46565b90925090506127258583610e0e565b94506127318482610e0e565b935050505b60010161263a565b600060028251600281111561274f57fe5b1461275c57506000610de9565b61060061277a83606001518560c00151610d8d90919063ffffffff16565b8360200151670de0b6b3a7640000610def565b600060028251600281111561279e57fe5b146127ab57506000610de9565b6106006127c983608001518560e00151610d8d90919063ffffffff16565b8360400151670de0b6b3a7640000610def565b6000808060001985870986860292508281109083900303905080612812576000841161280757600080fd5b508290049050610600565b80841161281e57600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b60008060008360020b126128a2578260020b6128aa565b8260020b6000035b9050620d89e88111156128e8576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b6000600182166128fc57600160801b61290e565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff1690506002821615612942576ffff97272373d413259a46990580e213a0260801c5b6004821615612961576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615612980576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b601082161561299f576fffcb9843d60f6159c9db58835c9266440260801c5b60208216156129be576fff973b41fa98c081472e6896dfb254c00260801c5b60408216156129dd576fff2ea16466c96a3843ec78b326b528610260801c5b60808216156129fc576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615612a1c576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615612a3c576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615612a5c576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615612a7c576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615612a9c576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615612abc576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615612adc576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615612afc576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615612b1d576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615612b3d576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615612b5c576d2216e584f5fa1ea926041bedfe980260801c5b62080000821615612b79576b048a170391f7dc42444e8fa20260801c5b60008460020b1315612b94578060001981612b9057fe5b0490505b640100000000810615612ba8576001612bab565b60005b60ff16602082901c0192505050919050565b600080836001600160a01b0316856001600160a01b03161115612bde579293925b846001600160a01b0316866001600160a01b031611612c0957612c02858585612d72565b9150612c50565b836001600160a01b0316866001600160a01b03161015612c4257612c2e868585612d72565b9150612c3b858785612ddb565b9050612c50565b612c4d858585612ddb565b90505b94509492505050565b600080600080612c6b888888886111e3565b91010398975050505050505050565b60006106006002848401810b0561288b565b60b581600160881b8110612ca55760409190911b9060801c5b69010000000000000000008110612cc15760209190911b9060401c5b650100000000008110612cd95760109190911b9060201c5b63010000008110612cef5760089190911b9060101c5b62010000010260121c80820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c908190048111900390565b6000818311612d3f5781610600565b5090919050565b600080612d6586612d568761288b565b612d5f8761288b565b86612bbd565b9150915094509492505050565b6000826001600160a01b0316846001600160a01b03161115612d92579192915b836001600160a01b0316612dcb606060ff16846001600160801b0316901b8686036001600160a01b0316866001600160a01b03166127dc565b81612dd257fe5b04949350505050565b6000826001600160a01b0316846001600160a01b03161115612dfb579192915b612102826001600160801b03168585036001600160a01b0316600160601b6127dc565b6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001606081525090565b6040518060800160405280600081526020016000815260200160008152602001606081525090565b6040518060800160405280612e96612f20565b8152602001612ea3612ef8565b8152602001612eb0612ef8565b8152602001612ebd612ef8565b905290565b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001606081525090565b6040518060800160405280600081526020016000815260200160008152602001600081525090565b60405180606001604052806000815260200160008152602001600081525090565b60408051608081018252600080825260208201819052918101829052606081019190915290565b80356123028161373c565b600082601f830112612f83578081fd5b81356020612f98612f938361371f565b6136fc565b8281528181019085830160c080860288018501891015612fb6578687fd5b865b868110156130415781838b031215612fce578788fd5b604080518381018181106001600160401b0382111715612fea57fe5b8252612ff58561304f565b8152878501358882015261300a8286016132fe565b91810191909152606084810135908201526080808501359082015260a0808501359082015285529385019391810191600101612fb8565b509198975050505050505050565b8035801515811461230257600080fd5b600060a08284031215613070578081fd5b60405160a081018181106001600160401b038211171561308c57fe5b6040529050808235600381106130a157600080fd5b80825250602083013560208201526040830135604082015260608301356060820152608083013560808201525092915050565b600061032082840312156130e6578081fd5b6130f16101606136fc565b90506130fc82612f68565b815261310a60208301612f68565b602082015261311b60408301613315565b604082015261312c60608301612f68565b606082015261313d60808301612f68565b608082015261314e60a0830161304f565b60a082015260c082013560c082015261316a8360e084016131a1565b60e082015261317d836101e084016131a1565b6101008201526102e082013561012082015261030082013561014082015292915050565b60006101008083850312156131b4578182fd5b604051908101906001600160401b03821181831017156131d057fe5b81604052809250833581526020840135602082015260408401356040820152606084013560608201526080840135608082015260a084013560a082015260c084013560c082015260e084013560e0820152505092915050565b60006080828403121561323a578081fd5b604051608081016001600160401b03828210818311171561325757fe5b81604052829350843583526020915081850135828401526040850135604084015260608501358181111561328a57600080fd5b85019050601f8101861361329d57600080fd5b80356132ab612f938261371f565b81815283810190838501858402850186018a10156132c857600080fd5b600094505b838510156132eb5780358352600194909401939185019185016132cd565b5080606087015250505050505092915050565b80356001600160801b038116811461230257600080fd5b803562ffffff8116811461230257600080fd5b6000806040838503121561333a578182fd5b82356001600160401b0380821115613350578384fd5b908401906101808287031215613364578384fd5b60405160808101818110838211171561337957fe5b6040528235815261338d876020850161305f565b602082015261339f8760c0850161305f565b6040820152610160830135828111156133b6578586fd5b6133c288828601612f73565b6060830152509660209590950135955050505050565b60008060008061038085870312156133ee578182fd5b84356001600160401b03811115613403578283fd5b61340f87828801613229565b9450506020850135925060408501359150611bc386606087016130d4565b60008060008060006103a08688031215613445578283fd5b85356001600160401b0381111561345a578384fd5b61346688828901613229565b955050602086013593506040860135925061348487606088016130d4565b91506103808601356134958161373c565b809150509295509295909350565b600080600061036084860312156134b8578081fd5b83356001600160401b038111156134cd578182fd5b6134d986828701613229565b935050602084013591506134f085604086016130d4565b90509250925092565b805182526020810151602083015260408101516040830152606081015160608301525050565b901515815260200190565b60208082526003908201526205043360ec1b604082015260600190565b600060208083526101008301845182850152818501516040818187015280870151915060608281880152808801519250608083818901528089015160a089015260a089015160c089015260c0890151935060e0808901528484518087526101208a01915087860196508895505b80861015613600578651805115158352888101516001600160801b03168984015285810151600290810b8785015290850151900b848301529587019560019590950194908201906135b4565b509998505050505050505050565b6020808252825182820152828101516040808401919091528084015160608085019190915280850151608080860152805160a08601819052600094939184019285929160c08801905b808510156136d857855180518051845288810151898501528501518584015287810151613686858501826134f9565b5080850151805160e085015288810151610100850152808601516101208501528401516101408401528301516136c06101608401826134f9565b506101e0820191508686019550600185019450613657565b5098975050505050505050565b90815260200190565b918252602082015260400190565b6040518181016001600160401b038111828210171561371757fe5b604052919050565b60006001600160401b0382111561373257fe5b5060209081020190565b6001600160a01b038116811461375157600080fd5b5056fe5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a264697066735822122024d6a10742361d99b22cb600e6806c8374aba25641086dde4ec5697c4271518b64736f6c63430007060033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061006c5760003560e01c8063213f76c41461007157806322b4a7841461009a57806329399f42146100ad5780634a3cb0c7146100cd57806375c3f240146100ed578063bb1a8b061461010e575b600080fd5b61008461007f366004613328565b61012e565b60405161009191906136e5565b60405180910390f35b6100846100a8366004613328565b61028e565b6100c06100bb3660046133d8565b6103ac565b6040516100919190613547565b6100e06100db3660046134a3565b610417565b604051610091919061351f565b6101006100fb366004613328565b610607565b6040516100919291906136ee565b61012161011c36600461342d565b610717565b604051610091919061360e565b6000805b8360600151518110156102875760008460600151828151811061015157fe5b60209081029190910181015181015160008181528683526040908190208151610100810183528154600281810b810b810b835263010000008204810b810b810b96830196909652600160301b90046001600160801b0316928101929092526001810154606080840191909152938101546080830152600381015460a0830152600481015460c08301526005015460e082015291870151805191935090849081106101f757fe5b6020026020010151600001511561027d5761027a6102736102408860600151868151811061022157fe5b6020026020010151606001518460800151610d8d90919063ffffffff16565b8860600151868151811061025057fe5b6020026020010151604001516001600160801b0316670de0b6b3a7640000610def565b8590610e0e565b93505b5050600101610132565b5092915050565b6000805b836060015151811015610287576000846060015182815181106102b157fe5b60209081029190910181015181015160008181528683526040908190208151610100810183528154600281810b810b810b835263010000008204810b810b810b96830196909652600160301b90046001600160801b0316928101929092526001810154606080840191909152938101546080830152600381015460a0830152600481015460c08301526005015460e0820152918701518051919350908490811061035757fe5b6020026020010151600001516103a25761039f6102736102408860600151868151811061038057fe5b6020026020010151606001518460600151610d8d90919063ffffffff16565b93505b5050600101610292565b6103b4612e1e565b60006103c286868686610e68565b602081015160408085019190915281015160608085019190915281015160808085019190915281015160a080850191909152015160c08301525061040885858585610e84565b60208301528152949350505050565b6000805b8460600151518110156105fa576105e48460008760600151848151811061043e57fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff16600281111561049757fe5b60028111156104a257fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff16600281111561050057fe5b600281111561050b57fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b828210156105d65760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a08301529083529092019101610560565b505050508152505084610eb3565b6105f2576000915050610600565b60010161041b565b50600190505b9392505050565b60008060005b84606001515181101561070f5760008560600151828151811061062c57fe5b60200260200101516020015190506000806106e38860600151858151811061065057fe5b60209081029190910181015160008681528a83526040908190208151610100810183528154600281810b810b810b835263010000008204810b810b810b96830196909652600160301b90046001600160801b03169281019290925260018101546060830152928301546080820152600383015460a0820152600483015460c082015260059092015460e083015290610f18565b90925090506106f28683610e0e565b95506106fe8582610e0e565b9450506001909201915061060d9050565b509250929050565b61071f612e5b565b60008660600151516001600160401b038111801561073c57600080fd5b5060405190808252806020026020018201604052801561077657816020015b610763612e83565b81526020019060019003908161075b5790505b50905060005b876060015151811015610d1e5760006109498860008b6060015185815181106107a157fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff1660028111156107fa57fe5b600281111561080557fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff16600281111561086357fe5b600281111561086e57fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b828210156109395760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a083015290835290920191016108c3565b5050505081525050888888610f89565b90506000610b098960008c60600151868151811061096357fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff1660028111156109bc57fe5b60028111156109c757fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff166002811115610a2557fe5b6002811115610a3057fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b82821015610afb5760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a08301529083529092019101610a85565b505050508152505089610fdc565b90506000610cc98a60008d606001518781518110610b2357fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff166002811115610b7c57fe5b6002811115610b8757fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff166002811115610be557fe5b6002811115610bf057fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b82821015610cbb5760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a08301529083529092019101610c45565b505050508152505089611030565b90506040518060800160405280610ce78584868c8e60a00151611071565b815260200184815260200182815260200183815250858581518110610d0857fe5b602090810291909101015250505060010161077c565b506000610d2d888888886103ac565b90506000806000610d4584888a60a0015160006111e3565b92509250925060405180608001604052808284038152602001848152602001610d73868a8c60a00151611316565b815260200186815250955050505050505b95945050505050565b600082821115610de4576040805162461bcd60e51b815260206004820152601e60248201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604482015290519081900360640190fd5b508082035b92915050565b828202811515841585830485141716610e0757600080fd5b0492915050565b600082820183811015610600576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b610e70612ec2565b610d84610e7f8686868661139a565b6115ea565b600080600080610e96888888886117e7565b60208a01516040909a015199909101999801979650505050505050565b6000610ed083602001518360e00151611a2e90919063ffffffff16565b151580610eef57506040830151610100830151610eec91611a2e565b15155b15610efc57506000610de9565b60608301515115610f0f57506000610de9565b50600192915050565b600080836000015115610f8257610f5f610f4385608001518560a00151610d8d90919063ffffffff16565b85604001516001600160801b0316670de0b6b3a7640000610def565b9150610f7f610f438560a001518560c00151610d8d90919063ffffffff16565b90505b9250929050565b610f91612ef8565b600080610fa087878787611a72565b91509150600080610fb389898989611af5565b604080516080810182529687526020870195909552938501525050606082015295945050505050565b610fe4612ef8565b600080610ff18585610607565b915091506040518060800160405280838152602001828152602001611016878761012e565b8152602001611025878761028e565b905295945050505050565b611038612ef8565b6000806000806110488787611b49565b604080516080810182529485526020850193909352918301526060820152979650505050505050565b611079612f20565b600061108e83856001600160a01b0316611bce565b905060008660400151876000015103905060008760600151886020015103905086600001518201915086602001518101905060006110dd88606001518960400151611c9490919063ffffffff16565b905085156111745760405180606001604052806111158c6000015161110f8e6020015189670de0b6b3a7640000610def565b90610e0e565b81526020016111398c6040015161110f8e6060015189670de0b6b3a7640000610def565b8152602001611166836111608781670de0b6b3a764000061115a8a8d611cf9565b90611da2565b90611e5a565b815250945050505050610d84565b604051806060016040528061119e8c6020015161110f8e6000015189670de0b6b3a7640000610def565b81526020016111c28c6060015161110f8e6040015189670de0b6b3a7640000610def565b8152602001611166836111608681670de0b6b3a764000061115a8b8d611cf9565b6000806000806111fc86886001600160a01b0316611bce565b905085156112395761123261122a670de0b6b3a764000061115a848c60200151611cf990919063ffffffff16565b895190611e5a565b9350611267565b6112648860200151611160670de0b6b3a764000061115a858d60000151611cf990919063ffffffff16565b93505b6000806000806112788c8c8b611ebf565b935093509350935089156112ce576112a5610273670de0b6b3a764000061129f8689612033565b9061208c565b96506112c76112c0670de0b6b3a764000061129f8489612033565b8390610e0e565b9550611307565b6112e88361110f670de0b6b3a764000061129f888a612033565b96506113048161110f670de0b6b3a764000061129f868a612033565b95505b50505050509450945094915050565b6000806113248585856120f3565b9050600061133386868661210a565b9050600061134487878760006111e3565b925050506113708261136a85611160620f424061129f87611364896122d2565b90612033565b90611c94565b9350620f4240841280156113845750600081115b1561139057620f424093505b5050509392505050565b60608460600151516001600160401b03811180156113b757600080fd5b506040519080825280602002602001820160405280156113f157816020015b6113de612ec2565b8152602001906001900390816113d65790505b50905060005b8560600151518110156115e1576115c2818660008960600151858151811061141b57fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff16600281111561147457fe5b600281111561147f57fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff1660028111156114dd57fe5b60028111156114e857fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b828210156115b35760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a0830152908352909201910161153d565b50505050815250508686612307565b8282815181106115ce57fe5b60209081029190910101526001016113f7565b50949350505050565b6115f2612ec2565b6000805b83518110156116295783818151811061160b57fe5b602002602001015160a00151518201915080806001019150506115f6565b506000816001600160401b038111801561164257600080fd5b5060405190808252806020026020018201604052801561167c57816020015b611669612f41565b8152602001906001900390816116615790505b5090506040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001828152509250600080600090505b85518110156117de578581815181106116d057fe5b6020026020010151602001518560200181815101915081815250508581815181106116f757fe5b60200260200101516040015185604001818151019150818152505085818151811061171e57fe5b60200260200101516060015185606001818151019150818152505085818151811061174557fe5b60200260200101516080015185608001818151019150818152505060005b86828151811061176f57fe5b602002602001015160a00151518110156117d55786828151811061178f57fe5b602002602001015160a0015181815181106117a657fe5b60200260200101518660a0015184815181106117be57fe5b602090810291909101015260019283019201611763565b506001016116bb565b50505050919050565b60008060005b866060015151811015611a245760008660008960600151848151811061180f57fe5b6020026020010151815260200190815260200160002060405180608001604052908160008201548152602001600182016040518060a00160405290816000820160009054906101000a900460ff16600281111561186857fe5b600281111561187357fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600682016040518060a00160405290816000820160009054906101000a900460ff1660028111156118d157fe5b60028111156118dc57fe5b81526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600b8201805480602002602001604051908101604052809291908181526020016000905b828210156119a75760008481526020908190206040805160c08101825260068602909201805460ff16151583526001808201548486015260028201546001600160801b03169284019290925260038101546060840152600481015460808401526005015460a08301529083529092019101611931565b505050508152505090506000806119bf838989612558565b915091506000806000806119d3878c611b49565b929650909450925090506119f56119ee8361136a8988611e5a565b8b90611e5a565b9950611a0f611a088261136a8887611e5a565b8a90611e5a565b985050600190960195506117ed945050505050565b5094509492505050565b6000600182516002811115611a3f57fe5b1415611a6757611a6082604001518460a00151670de0b6b3a7640000610def565b9050610de9565b506040810151610de9565b600080611a936112c087602001518660e001516125f790919063ffffffff16565b9150611abb611ab487604001518661010001516125f790919063ffffffff16565b8290610e0e565b9050600080611acd8888876001612634565b9092509050611adc8483610e0e565b9350611ae88382610e0e565b9250505094509492505050565b600080611b166112c087602001518660e00151611a2e90919063ffffffff16565b9150611b37611ab48760400151866101000151611a2e90919063ffffffff16565b9050600080611acd8888876000612634565b600080600080611b6a86602001518660e0015161273e90919063ffffffff16565b9350611b88866040015186610100015161273e90919063ffffffff16565b9250611ba586602001518660e0015161278d90919063ffffffff16565b9150611bc3866040015186610100015161278d90919063ffffffff16565b905092959194509250565b6000670de0b6b3a76400008315611c3657611bf7838483600160c01b81611bf157fe5b046127dc565b915081611c16576ec097ce7bc90715b34b9f1000000000915050610de9565b816ec097ce7bc90715b34b9f100000000081611c2e57fe5b049150611c57565b600160601b81611c4b8586600160601b6127dc565b0281611c5357fe5b0491505b6ec097ce7bc90715b34b9f1000000000821115611c85576ec097ce7bc90715b34b9f10000000009150610287565b81610287575060019392505050565b6000818303818312801590611ca95750838113155b80611cbe5750600083128015611cbe57508381135b6106005760405162461bcd60e51b81526004018080602001828103825260248152602001806137df6024913960400191505060405180910390fd5b600082611d0857506000610de9565b82600019148015611d1c5750600160ff1b82145b15611d585760405162461bcd60e51b81526004018080602001828103825260278152602001806137b86027913960400191505060405180910390fd5b82820282848281611d6557fe5b05146106005760405162461bcd60e51b81526004018080602001828103825260278152602001806137b86027913960400191505060405180910390fd5b600081611df6576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b81600019148015611e0a5750600160ff1b83145b15611e465760405162461bcd60e51b81526004018080602001828103825260218152602001806137766021913960400191505060405180910390fd5b6000828481611e5157fe5b05949350505050565b6000828201818312801590611e6f5750838112155b80611e845750600083128015611e8457508381125b6106005760405162461bcd60e51b81526004018080602001828103825260218152602001806137556021913960400191505060405180910390fd5b60408301516060840151608085015160a086015160005b8760c00151518110156120295760008860c001518281518110611ef557fe5b602002602001015190506000611f0e826040015161288b565b90506000611f1f836060015161288b565b9050888015611f2d57508251155b8015611f4b5750896001600160a01b0316826001600160a01b031611155b8015611f695750806001600160a01b03168a6001600160a01b031611155b15611fc657611fbc611fb5600160601b61129f611f89876040015161288b565b611f96886060015161288b565b60208901516001600160801b0316916001600160a01b03910316612033565b8690610e0e565b9450505050612021565b600080611fd98c85858860200151612bbd565b865191935091501561200257611fef8a83610e0e565b9950611ffb8982610e0e565b985061201b565b61200c8883610e0e565b97506120188782610e0e565b96505b50505050505b600101611ed6565b5093509350935093565b60008261204257506000610de9565b8282028284828161204f57fe5b04146106005760405162461bcd60e51b81526004018080602001828103825260218152602001806137976021913960400191505060405180910390fd5b60008082116120e2576040805162461bcd60e51b815260206004820152601a60248201527f536166654d6174683a206469766973696f6e206279207a65726f000000000000604482015290519081900360640190fd5b8183816120eb57fe5b049392505050565b60006121028484846000612c59565b949350505050565b6001600160ff1b036305f5e1006001600160a01b0363057caf768502811682900491630679875d86028216049085166401000276a3108015612168575073fffd8963efd1fc6a506488495d951d5263988d266001600160a01b038616105b61218d5760405162461bcd60e51b81526004016121849061352a565b60405180910390fd5b6401000276a36001600160a01b03831610156121ac576401000276a391505b73fffd8963efd1fc6a506488495d951d5263988d266001600160a01b03821611156121e8575073fffd8963efd1fc6a506488495d951d5263988d265b60006121f58783876120f3565b905080841315612203578093505b5060006122118784876120f3565b90508084131561221f578093505b5060005b8660c00151518110156113905760008760c00151828151811061224257fe5b6020026020010151905080600001516122c857600061226982606001518360400151612c7a565b9050846001600160a01b0316816001600160a01b0316108061229c5750806001600160a01b0316846001600160a01b0316105b156122a85750506122ca565b60006122b78a838a6001612c59565b9050808713156122c5578096505b50505b505b600101612223565b60006122ff6122f7620f424061129f6122ef86620f424002612c8c565b603290612033565b614e20612d30565b90505b919050565b61230f612ec2565b60008460600151516001600160401b038111801561232c57600080fd5b5060405190808252806020026020018201604052801561236657816020015b612353612f41565b81526020019060019003908161234b5790505b50905060005b8560600151518110156124b75760008660600151828151811061238b57fe5b60209081029190910181015181015160008181528883526040908190208151610100810183528154600281810b810b810b835263010000008204810b810b810b96830196909652600160301b90046001600160801b031681840152600182015460608083019190915294820154608080830191909152600383015460a0830152600483015460c083015260059092015460e08201528251918201909252928a015180519294509092918291908690811061244157fe5b602002602001015160000151151581526020018960600151858151811061246457fe5b6020026020010151604001516001600160801b03168152602001826000015160020b8152602001826020015160020b8152508484815181106124a257fe5b6020908102919091010152505060010161236c565b506040518060c001604052808781526020016124e487602001518660e001516125f790919063ffffffff16565b815260200161250587604001518661010001516125f790919063ffffffff16565b815260200161252587602001518660e00151611a2e90919063ffffffff16565b81526020016125468760400151866101000151611a2e90919063ffffffff16565b81526020019190915295945050505050565b6000806000806125688787610607565b90925090506125778483611e5a565b93506125838382611e5a565b92508460a00151156125c0576125a361259c888861012e565b8590611e5a565b93506125b96125b2888861028e565b8590611c94565b93506125ed565b6125d46125cd888861012e565b8490611e5a565b92506125ea6125e3888861028e565b8490611c94565b92505b5050935093915050565b600060018251600281111561260857fe5b141561262957611a6082602001518460800151670de0b6b3a7640000610def565b506020810151610de9565b60008060005b866060015151811015611a24578660600151818151811061265757fe5b60200260200101516000015115158415151461267257612736565b600080612716878960008c60600151878151811061268c57fe5b602002602001015160200151815260200190815260200160002060000160009054906101000a900460020b8a60008d6060015188815181106126ca57fe5b602002602001015160200151815260200190815260200160002060000160039054906101000a900460020b8c60600151878151811061270557fe5b602002602001015160400151612d46565b90925090506127258583610e0e565b94506127318482610e0e565b935050505b60010161263a565b600060028251600281111561274f57fe5b1461275c57506000610de9565b61060061277a83606001518560c00151610d8d90919063ffffffff16565b8360200151670de0b6b3a7640000610def565b600060028251600281111561279e57fe5b146127ab57506000610de9565b6106006127c983608001518560e00151610d8d90919063ffffffff16565b8360400151670de0b6b3a7640000610def565b6000808060001985870986860292508281109083900303905080612812576000841161280757600080fd5b508290049050610600565b80841161281e57600080fd5b6000848688096000868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010186841190950394909402919094039290920491909117919091029150509392505050565b60008060008360020b126128a2578260020b6128aa565b8260020b6000035b9050620d89e88111156128e8576040805162461bcd60e51b81526020600482015260016024820152601560fa1b604482015290519081900360640190fd5b6000600182166128fc57600160801b61290e565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff1690506002821615612942576ffff97272373d413259a46990580e213a0260801c5b6004821615612961576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615612980576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b601082161561299f576fffcb9843d60f6159c9db58835c9266440260801c5b60208216156129be576fff973b41fa98c081472e6896dfb254c00260801c5b60408216156129dd576fff2ea16466c96a3843ec78b326b528610260801c5b60808216156129fc576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615612a1c576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615612a3c576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615612a5c576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615612a7c576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615612a9c576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615612abc576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615612adc576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615612afc576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615612b1d576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615612b3d576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615612b5c576d2216e584f5fa1ea926041bedfe980260801c5b62080000821615612b79576b048a170391f7dc42444e8fa20260801c5b60008460020b1315612b94578060001981612b9057fe5b0490505b640100000000810615612ba8576001612bab565b60005b60ff16602082901c0192505050919050565b600080836001600160a01b0316856001600160a01b03161115612bde579293925b846001600160a01b0316866001600160a01b031611612c0957612c02858585612d72565b9150612c50565b836001600160a01b0316866001600160a01b03161015612c4257612c2e868585612d72565b9150612c3b858785612ddb565b9050612c50565b612c4d858585612ddb565b90505b94509492505050565b600080600080612c6b888888886111e3565b91010398975050505050505050565b60006106006002848401810b0561288b565b60b581600160881b8110612ca55760409190911b9060801c5b69010000000000000000008110612cc15760209190911b9060401c5b650100000000008110612cd95760109190911b9060201c5b63010000008110612cef5760089190911b9060101c5b62010000010260121c80820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c908190048111900390565b6000818311612d3f5781610600565b5090919050565b600080612d6586612d568761288b565b612d5f8761288b565b86612bbd565b9150915094509492505050565b6000826001600160a01b0316846001600160a01b03161115612d92579192915b836001600160a01b0316612dcb606060ff16846001600160801b0316901b8686036001600160a01b0316866001600160a01b03166127dc565b81612dd257fe5b04949350505050565b6000826001600160a01b0316846001600160a01b03161115612dfb579192915b612102826001600160801b03168585036001600160a01b0316600160601b6127dc565b6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001606081525090565b6040518060800160405280600081526020016000815260200160008152602001606081525090565b6040518060800160405280612e96612f20565b8152602001612ea3612ef8565b8152602001612eb0612ef8565b8152602001612ebd612ef8565b905290565b6040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001606081525090565b6040518060800160405280600081526020016000815260200160008152602001600081525090565b60405180606001604052806000815260200160008152602001600081525090565b60408051608081018252600080825260208201819052918101829052606081019190915290565b80356123028161373c565b600082601f830112612f83578081fd5b81356020612f98612f938361371f565b6136fc565b8281528181019085830160c080860288018501891015612fb6578687fd5b865b868110156130415781838b031215612fce578788fd5b604080518381018181106001600160401b0382111715612fea57fe5b8252612ff58561304f565b8152878501358882015261300a8286016132fe565b91810191909152606084810135908201526080808501359082015260a0808501359082015285529385019391810191600101612fb8565b509198975050505050505050565b8035801515811461230257600080fd5b600060a08284031215613070578081fd5b60405160a081018181106001600160401b038211171561308c57fe5b6040529050808235600381106130a157600080fd5b80825250602083013560208201526040830135604082015260608301356060820152608083013560808201525092915050565b600061032082840312156130e6578081fd5b6130f16101606136fc565b90506130fc82612f68565b815261310a60208301612f68565b602082015261311b60408301613315565b604082015261312c60608301612f68565b606082015261313d60808301612f68565b608082015261314e60a0830161304f565b60a082015260c082013560c082015261316a8360e084016131a1565b60e082015261317d836101e084016131a1565b6101008201526102e082013561012082015261030082013561014082015292915050565b60006101008083850312156131b4578182fd5b604051908101906001600160401b03821181831017156131d057fe5b81604052809250833581526020840135602082015260408401356040820152606084013560608201526080840135608082015260a084013560a082015260c084013560c082015260e084013560e0820152505092915050565b60006080828403121561323a578081fd5b604051608081016001600160401b03828210818311171561325757fe5b81604052829350843583526020915081850135828401526040850135604084015260608501358181111561328a57600080fd5b85019050601f8101861361329d57600080fd5b80356132ab612f938261371f565b81815283810190838501858402850186018a10156132c857600080fd5b600094505b838510156132eb5780358352600194909401939185019185016132cd565b5080606087015250505050505092915050565b80356001600160801b038116811461230257600080fd5b803562ffffff8116811461230257600080fd5b6000806040838503121561333a578182fd5b82356001600160401b0380821115613350578384fd5b908401906101808287031215613364578384fd5b60405160808101818110838211171561337957fe5b6040528235815261338d876020850161305f565b602082015261339f8760c0850161305f565b6040820152610160830135828111156133b6578586fd5b6133c288828601612f73565b6060830152509660209590950135955050505050565b60008060008061038085870312156133ee578182fd5b84356001600160401b03811115613403578283fd5b61340f87828801613229565b9450506020850135925060408501359150611bc386606087016130d4565b60008060008060006103a08688031215613445578283fd5b85356001600160401b0381111561345a578384fd5b61346688828901613229565b955050602086013593506040860135925061348487606088016130d4565b91506103808601356134958161373c565b809150509295509295909350565b600080600061036084860312156134b8578081fd5b83356001600160401b038111156134cd578182fd5b6134d986828701613229565b935050602084013591506134f085604086016130d4565b90509250925092565b805182526020810151602083015260408101516040830152606081015160608301525050565b901515815260200190565b60208082526003908201526205043360ec1b604082015260600190565b600060208083526101008301845182850152818501516040818187015280870151915060608281880152808801519250608083818901528089015160a089015260a089015160c089015260c0890151935060e0808901528484518087526101208a01915087860196508895505b80861015613600578651805115158352888101516001600160801b03168984015285810151600290810b8785015290850151900b848301529587019560019590950194908201906135b4565b509998505050505050505050565b6020808252825182820152828101516040808401919091528084015160608085019190915280850151608080860152805160a08601819052600094939184019285929160c08801905b808510156136d857855180518051845288810151898501528501518584015287810151613686858501826134f9565b5080850151805160e085015288810151610100850152808601516101208501528401516101408401528301516136c06101608401826134f9565b506101e0820191508686019550600185019450613657565b5098975050505050505050565b90815260200190565b918252602082015260400190565b6040518181016001600160401b038111828210171561371757fe5b604052919050565b60006001600160401b0382111561373257fe5b5060209081020190565b6001600160a01b038116811461375157600080fd5b5056fe5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a264697066735822122024d6a10742361d99b22cb600e6806c8374aba25641086dde4ec5697c4271518b64736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Error Codes V0: no permission",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}